{"version":3,"file":"js/tartib.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,SAAU,GAAIH,GACK,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,GAClB,CATD,CASGK,MAAM,WACT,O,wBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,SAASL,EAASM,GACzC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAG3E,ECPAF,EAAwB,SAASQ,EAAKC,GAAQ,OAAOL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,EAAO,G,2CCA/F,MAAMI,EAAOC,SACPC,EAAOF,EAAKG,gBACZC,EAAOJ,EAAKK,KAEZC,EAAgB,cAChBC,EAAe,WAEfC,EAAc,QACdC,EAAa,OACbC,EAAa,OACbC,EAAe,UAGf,MAAEC,EAAF,IAASC,GAAQC,KAGjBC,EAAU,CACnBC,EAAG,CACLC,EAAiB,aACjBC,EAAkB,cAClBC,EAAa,OACbC,EAAa,QACbC,EAAY,SAGbC,EAAG,CACFL,EAAiB,YACjBC,EAAkB,eAClBC,EAAa,MACbC,EAAa,SACbC,EAAY,WCvBDE,EAAiB,CAACC,EAAQC,KACnC,IAAK,MAAMpC,KAAOmC,EACVjC,OAAOO,eAAeC,KAAKyB,EAAQnC,IACnCoC,EAAGD,EAAOnC,GAAMA,EAEvB,EAUQqC,EAAQ,CAACC,KAAWC,IAAYrC,OAAOsC,OAAOF,KAAWC,GCtBzDE,EAAW,CASpBC,SAAU,CAAC,EAOXC,OAAQ,GAORC,WAAW,EAQXC,OAAQ,GAORC,YAAa,GAObC,WAAY,GAOZC,KAAM,GAONC,UAAU,EAQVC,QAAS,EAOTC,YAAY,EAOZC,KAAK,GC/EIC,EAAgB,gBAEhBC,EAAwB,sBCQxBC,EAAyB,CAACC,EAAcC,EAAYC,EAAeV,EAAMW,EAAOC,KAEzF,IAAIC,EACAC,EAAUpC,EAAQsB,GAIlBe,EAA0BL,EAAgBF,EAAaR,GAA2C,GAAnCQ,EAAaM,EAAQ9B,GAiBxF,OAfeyB,EAAWT,GAAQU,GAK1BK,GAA2BH,KAC3BC,EAAWF,EAAQ1C,EAAgBC,GAIjC6C,IAA2BH,IAC7BC,EAAWF,EAAQzC,EAAeD,GAInC4C,CAAP,EC9BSG,EAAWC,GAA0B,iBAAVA,EAQ3BC,EAAa,CAACC,EAAQlB,KAC/BkB,EAAOC,OAAOnB,SAAWA,CAAzB,ECHSoB,EAAa,CAACC,EAAKC,EAASC,IAAQR,EAASM,GAAOA,IAAQC,GAAW5D,GAAM,iBAAmB6D,EAAM,MAAQ,KAAKF,GAC9FA,aAAeG,QAAUH,EACzB,KASrBI,EAAaC,GAAOA,GAAMA,EAAGC,wBAQ7BC,EAAYF,GAAMA,EAAGG,cAQrBC,EAAe,CAACJ,EAAIK,KAEzBA,EACA9C,EAAe8C,GAAQ,CAACf,EAAOgB,KAC3BN,EAAGO,MAAMD,GAAYhB,CAArB,IAGJU,EAAGO,MAAQ,IACd,EAUCC,EAAa,CAACR,EAAIS,EAASC,KAEzBD,IACIpB,EAASoB,KACTA,EAAU,CAACA,IAGfA,EAAQE,SAAQC,IACZvB,EAASuB,IAAcA,EAAUC,MAAM,OAAOF,SAAQG,IAC9CA,GACAd,EAAGe,UAAUL,EAAS,SAAW,OAAOI,EAC3C,GAHL,IAMP,EASQC,EAAaf,IAAD,CAMrBgB,EAAKP,GACDQ,KAAKC,EAAWT,EAChBD,EAAWR,EAAIS,EAClB,EAKDU,IACIX,EAAWR,EAAIiB,KAAKC,GAAU,EACjC,ICrFQE,EAAS,CAACpB,EAAIqB,EAAUC,EAAYjD,EAAMW,KAKnD,IAMIuC,GANA,EAAEpE,EAAF,EAAeC,EAAf,EAA4BH,EAA5B,EAA6CC,EAA7C,EAA+DG,GAAeN,EAAQsB,GAOtFmD,EAAe3E,EAAImD,EAAG/C,IACtBwE,EAAaD,EAAe,EAC5BE,EAAiBF,EAAexB,EAAG9C,GAAoBmE,EAAShE,IAG9D2B,EAAQ0C,EAAiBD,IAAeH,EAAWnE,GAAekE,EAASlE,GAC7EoE,EAAgBpE,GAER6B,EAAQyC,EAAaC,IAAmBJ,EAAWlE,GAAeiE,EAASjE,KACnFmE,EAAgBnE,GAGhBmE,IACAvB,EAAG/C,IAAoBqE,EAAWC,GAAiBF,EAASE,GAC/D,ECrBQI,EAAe,CAACC,EAAM7D,EAAU8D,EAASC,EAAQ9C,KPetCM,MOdpBvB,EPc8C,iBAA1BuB,EOdAvB,IPc+C,MAATuB,GAAmByC,MAAMC,QAAQ1C,GOdhD,CAAC,EAAZvB,EAEhC,IAGIkE,EAHAC,EAASnC,EAAU+B,GAAUF,GAC7BN,EAAaQ,EAAS/B,EAAU6B,GAAQM,EACxCC,EAAQ,CAAC,EAkCb,OA/BA5E,EAAesE,GAAS,CAACO,EAAK/D,KAC1B4D,EAAUlE,EAASM,GAEH,KAAZ4D,GAAkBI,MAAMJ,GAGpBA,EADA5C,EAAS4C,IAAY,iBAAiBK,KAAKL,EAAQM,QACzCC,WAAWP,GAAWC,EAAOnF,EAAQsB,GAAMhB,GAAc,IAGzD,KAId4E,GAAW,EAIA,MAAXA,GAEIjD,GAAkB,MAATX,IACT4D,EAAUC,EAAOO,MAAQR,GAG7BA,GAAWC,EAAO7D,IAElB4D,EAAUG,EAGdD,EAAM9D,GAAQ4D,EAAUX,EAAWjD,EAAnC,IAGG8D,CAAP,EC9CSO,EAAoB,CAACC,EAAOC,EAAWzE,KAO5CyE,EANU,CACV,CAACtG,GAAgB,WACjB,CAACC,GAAe,QAIEoG,GAAS,oBAAsBxE,GACjDyE,EAAUC,sBAAsBF,EAAOxE,EAC1C,ECFQ2E,EAAYtD,IAErB,MAAM,GAAEQ,EAAF,OAAMP,EAAQsD,IAAI,EAAEC,IAAYxD,GAKhC,EAAEyD,EAAF,EAAYC,GCdFlD,KAAM,CAQtBiD,EAAUtF,GAAUA,EAAOwF,QAAQzE,GAQnCwE,IACK,IAAIE,EAAW1D,EAAWhB,EAAesB,GAAI,GACzCqD,EAAQ,GACRC,EAASF,EAASE,OAEtB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQC,IAAK,CAC7B,MAAMC,EAAUJ,EAASG,GAEnBC,EAAQzC,UAAU0C,SAAS9E,IAC7B0E,EAAMK,KAAKF,EAElB,CACD,OAAOH,CACV,IDf8BM,CAAK3D,IAK/B,EAAE4D,EAAF,EAASC,GEvBQ,MACvB,MAAMC,EAAY,GAQZC,EAAS,CAACC,EAAUC,KACtBD,EAAS,IAAIC,EAAS,SAAU,OAAS,iBAAiBD,EAAS,GAAIA,EAAS,GAAhF,EAGJ,MAAO,CAIHJ,EAAMjG,EAAQuG,EAAMC,GAChB,GAAIxG,EAAQ,CACR,IAAIqG,EAAW,CAACrG,EAAQuG,EAAMC,GAC9BJ,EAAOC,GACPF,EAAUJ,KAAKM,EAClB,CACJ,EAKDH,IACIC,EAAUnD,SAAQqD,IACdD,EAAOC,GAAU,EAAjB,GAEP,EAnBL,EFU0BI,GAO1B,IAAIC,EAOAlG,EAOAmG,EAcAhD,EAOAiD,EAqBAC,EAeAxF,EAOAyF,EA3DAC,EAAa,CACbC,EAAO5D,EAAUf,IAsBjB4E,EAAa,CAAC,EAOdC,EAAY,CAAC,EAYbC,GAAc,EAKdC,GAAa,EAmBjB,MAkNMC,EAAkB,CAAChI,EAAGM,EAAGe,KAEvBW,IACAhC,GAAKd,EAAKa,EAAQC,EAAEC,IAIpBoB,EAAKf,IACL+G,EAAY9D,MAAM0E,IAAM3H,EAAIuH,EAAUvH,EAAI,MAG1Ce,EAAKrB,IACLqH,EAAY9D,MAAM2E,KAAOlI,EAAI6H,EAAU7H,EAAI,KAC9C,EAWCmI,EAAmB,CAACC,EAAW/B,IAAUA,EAAMgC,KAAIzD,GAAQA,EAAK0D,aAAaF,GAAa,QAYhG,OAPAxB,EAAM5D,EAAI,eA/OQuF,IAEd,IAAI,WAAEnH,EAAF,SAAcL,EAAd,SAAwBO,EAAxB,WAAkCE,EAAlC,IAA8CC,EAA9C,KAAmDJ,EAAnD,OAAyDL,GAAWyB,GACpE,OAAE9B,EAAF,UAAU6H,EAAV,QAAqBC,EAArB,QAA8BC,EAA9B,OAAuCC,GAAWJ,EAGtDlB,EAAcpB,EAAStF,GAOnBW,IAAa+F,GAAesB,GAAWvH,GAAcT,IAAW+B,EAAWtB,EAAYiG,KAI3FrF,EAAQP,EACRgG,EAAW,CACPzH,EAAY,MAATqB,EACHf,EAAY,MAATe,GAGPV,EAAOiI,sBAAsBJ,GAC7BrH,EAAckG,EAAYwB,YAC1B1H,EAAY2H,GAAK,GACjBvB,EAAYrB,IAGZwB,EAAWqB,EAAQhF,EAAUsD,GAC7BK,EAAWsB,EAAejF,EAAU5C,GAEpCuG,EAAWC,EAAM3D,EPlJO,aOmJxBZ,EAAalE,EAAM,CAAE8B,WAErB4G,EAAa,CACT5H,EAAGyI,EACHnI,EAAGoI,GAGPlB,EAAc,CACVxE,KACAhD,EAAG,EACHM,EAAG,EACHK,OAAQ0G,EACR4B,cAAe,KACf9H,cACAkF,MAAOkB,EACP2B,QAAQd,GACJ,OAAOD,EAAiBC,EAAWnE,KAAKoC,MAC3C,GAGLwB,EAAYlD,EAAa0C,EAAatG,EAAU6G,EAAYxG,EAAaT,EAAS,KAAMqB,GACxFsF,EAAsB9F,EGrKSwB,KACnC,IAAIsE,EAAsB,GACtB6B,EAAWnG,EAAGoG,aACdC,EAAUrG,EAAGsG,YAEjB,KAAc,OAAPtG,GAAa,CAChB,IAAIuG,EAAWC,iBAAiBxG,GAAIuG,UAChC,MAAE9D,EAAF,OAASgE,GAAW1G,EAAUC,GAC9B0G,EAAS1G,IAAO9D,EAEhBwK,IACAD,EAASvK,EAAKyK,eAIA,SAAbJ,GAAoC,WAAbA,GAA0BG,GAAuB,YAAbH,KAE3DE,EAASN,GAAY1D,EAAQ4D,IAE9BrG,IAAO5D,GAEPkI,EAAoBZ,KAAK1D,GAG7BA,EAAKE,EAAUF,EAClB,CAED,OAAOsE,CAAP,EH0IuCsC,CAAuB5G,GAAM,GAChE+E,GAAa,EAAb,IAyLJnB,EAAM5H,EAAM,eAjLKuJ,IACb,GAAIR,EAAY,CACZ,IACI8B,GADElJ,OAAQsI,EAAV,QAAyBR,EAAzB,QAAkCC,GAAYH,EAGlD,IAAMT,EAAa,CACfE,EAAgBJ,EAAW5H,EAAG4H,EAAWtH,EAAG,CAAC,GAE7C,IAAI,UAAEW,EAAWE,YAAa2I,EAA1B,QAAgDvI,EAAhD,OAAyDL,GAAWuB,GACpE,MAAEgD,EAAF,OAASgE,EAAT,EAAiBzJ,EAAjB,EAAoBM,GAAMyC,EAAUsE,GAExCoC,GAAU,KACVhE,GAAS,KACTrC,EAAaiE,EAAa,CACtB5B,QACAgE,SACAlI,QAASA,EAAU,GAAKA,EAAU,GAAIA,IAE1C6B,EAAajC,EAAa,CAAEsI,WAK5BzD,EAAMxG,EAAagI,EAAa,CAAExH,IAAGM,MAErCoH,EAAWqB,EAAM/E,EAAK,CP7MA+F,wBO6MyB9I,GP3M5B,eO2M8DC,IACjFwG,EAAWsB,EAAahF,EAAK8F,GAAwBnI,GAErD+D,EAAkBpG,EAAe+H,EAAalG,GAC9C2G,GAAc,CACjB,CA0BD,GArBAE,EAAgBS,EAASC,EAASjB,GAElCnD,EAAavB,EAAUsE,GAEvBwC,EAAO,CACH7J,EAAGsE,EAAWtE,EACdM,EAAGgE,EAAWhE,GAMlB0F,EAAMvG,EAAY+H,EAAaqC,EAAM,CAAEZ,kBI1NxB,EAACe,EAAa1F,EAAYtC,KACjDgI,EAAYrG,SAAQsG,IAChB,IAAI/E,EAASnC,EAAUkH,GAEvB,GAAIA,IAAe/K,EAAM,CACrB,IAAIgL,EAAYhL,EAAKyK,aACjBlE,EAAQP,EAAOO,MAEnBP,EAAS,CACL+C,IAAK,EACLC,KAAM,EACNiC,MAAO1E,EACP2E,OAAQF,EACRT,OAAQS,EACRzE,QAEP,CAGDrB,EAAO6F,EAAY/E,EAAQZ,EAAY,IAAKtC,GAC5CoC,EAAO6F,EAAY/E,EAAQZ,EAAY,KAAK,EAA5C,GAnBJ,EJ8NQ9C,CAAW8F,EAAqBhD,EAAYtC,GAE5CiH,EAAgBhD,EAASgD,GAErBjG,EAAGyD,SAASwC,IAAkBA,IAAkB9H,EAAa,CAC7D,IAIIe,EAJAgD,EAASnC,EAAUkG,IACnB,IAAEhB,EAAF,MAAOkC,EAAP,OAAcC,EAAd,KAAsBlC,GAASnF,EAAU5B,GACzCkJ,EAAmB5B,GAAW7I,EAAMuK,IAAU1B,GAAW7I,EAAMsI,IAAST,EAASnH,EACjFgK,EAAqB5B,GAAW9I,EAAMwK,IAAW1B,GAAW9I,EAAMqI,IAAQR,EAASzH,GAIjFsK,IAAwBD,GAAqB5C,EAASzH,GAAKyH,EAASnH,GAEtE4B,EAAWN,EAAuBsD,EAAQ0C,EAAYa,EAAS,IAAKzG,GACpEE,EAAWN,EAAuBsD,EAAQ0C,EAAYc,EAAS,KAAK,EAAOxG,KAGrEoI,IACFpI,EAAWN,EAAuBsD,EAAQ0C,EAAYc,EAAS,KAAK,IAIlE2B,IACFnI,EAAWN,EAAuBsD,EAAQ0C,EAAYa,EAAS,IAAKzG,KAIxEE,IACAwD,EAAkBxD,EAAU+G,EAAe9H,GAC3CyG,EAAWtH,EAAIoI,EACfd,EAAW5H,EAAIyI,EAKfzC,EAAMtG,EAAY8H,EAAaqC,EAAM,CACjCZ,gBACA5C,MAAOH,MAGlB,CACJ,KAoFLU,EAAM5H,EAAM,aA5EIuJ,IACZ,GAAIR,EAAY,CAER7E,EAAU/B,KACV6B,EAAGuH,aAAalD,EAAalG,GAC7BA,EAAc,MAGlB,IAAIqJ,EAAUtE,IACV2D,EAAO,CACP1I,cACAkF,MAAOmE,GAGXpH,EAAaiE,GACbjE,EAAalE,EAAM,CAAE8B,OAAQ,KAE7B0G,EAAWqB,EAAM5E,IACjBuD,EAAWC,EAAMxD,IAEboD,EAAUkD,MAAK,CAAC7F,EAAM8F,IAAU9F,IAAS4F,EAAQE,MAIjD1E,EAAMrG,EAAc6H,EAAaqC,GAGjC/B,GAIA9B,EVjTS,MUiTQwB,EAAaqC,GAGlC9B,EAAaD,GAAc,CAC9B,KA0CLlB,EAAM5H,EAAM,iBAAiBuJ,IACzBR,EAAaD,GAAc,CAA3B,IAGG,CACHjB,IACAsB,IACAjC,IAHJ,EKtWW,MAAMyE,EAKH,eAAGC,QAKF,gBAAG9J,EAQlB+J,YAAYjF,EAAWkF,GACnB,MAAMtI,EAASyB,KACfzB,EAAOQ,GAAKN,EAAWkD,GACvBpD,EAAOC,OAAS/B,EAAM,CAAC,EAAGiK,EAAO7J,SAAUgK,GAC3CtI,EAAOuD,GCtBc,MAKzB,MAAMgF,EAAW,CACb,CAACvL,GAAc,GACf,CAACC,GAAa,GACd,CAACC,GAAa,GACd,CAACC,GAAe,GAChB,IAAa,IAGjB,MAAO,CAOHqG,EAAMkB,KAAS8D,GACXD,EAAS7D,GAAMvD,SAAQwD,IACnBA,EAAQzG,EAAM,CAAC,EAAG,CAAEwG,WAAW8D,GAA/B,GAEP,EAQDC,EAAI/D,EAAMC,GACN4D,EAAS7D,IAAS6D,EAAS7D,GAAMR,KAAKS,EACzC,EAQD+D,EAAKhE,EAAMC,GACP,IAAIgE,EAAgBJ,EAAS7D,GAEzBiE,EAGAJ,EAAS7D,GAAQC,EAAUgE,EAAcC,QAAOC,GAAmBA,IAAoBlE,IAAW,GAClF,OAATD,GACP3G,EAAewK,GAAU,CAACO,EAAKpE,KAC3B6D,EAAS7D,GAAQ,EAAjB,GAIX,EA1CL,EDSgBqE,GACZ/I,EAAOgJ,GAAK1F,EAAStD,EACxB,CAODiJ,WAAWX,GACPpK,EAAMuD,KAAKxB,OAAQqI,EACtB,CAQDY,GAAGxE,EAAMC,GACLlD,KAAK8B,GAAGkF,EAAI/D,EAAMC,EACrB,CAQDwE,IAAIzE,EAAMC,GACNlD,KAAK8B,GAAGmF,EAAKhE,EAAMC,EACtB,CAQD+B,QAAQd,GACJ,IAAItC,EAAW7B,KAAKuH,GACpB,OAAO1F,EAASqC,EAAiBC,EAAWtC,EAASI,IACxD,CAKD0F,UACIrJ,EAAW0B,MAAM,EACpB,CAKD4H,SACItJ,EAAW0B,MAAM,EACpB,CAKD6H,UACI,MAAMtJ,EAASyB,KAEfzB,EAAOgJ,GAAG3E,IACVtG,EAAeiC,GAAQ,CAAC4C,EAAKxG,YAClB4D,EAAO5D,EAAd,GAEP,E","sources":["webpack://Tartib/webpack/universalModuleDefinition","webpack://Tartib/webpack/bootstrap","webpack://Tartib/webpack/runtime/define property getters","webpack://Tartib/webpack/runtime/hasOwnProperty shorthand","webpack://Tartib/./src/js/constants.js","webpack://Tartib/./src/js/utils/object.js","webpack://Tartib/./src/js/defaults.js","webpack://Tartib/./src/js/utils/classes.js","webpack://Tartib/./src/js/placeholder/position.js","webpack://Tartib/./src/js/utils/util.js","webpack://Tartib/./src/js/utils/dom.js","webpack://Tartib/./src/js/scroll/scroll.js","webpack://Tartib/./src/js/utils/dragPoint.js","webpack://Tartib/./src/js/placeholder/insert.js","webpack://Tartib/./src/js/core/sortable.js","webpack://Tartib/./src/js/core/list.js","webpack://Tartib/./src/js/core/events/binder.js","webpack://Tartib/./src/js/scroll/scrollable.js","webpack://Tartib/./src/js/scroll/autoScroll.js","webpack://Tartib/./src/js/index.js","webpack://Tartib/./src/js/core/events/listener.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Tartib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tartib\"] = factory();\n\telse\n\t\troot[\"Tartib\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ROOT = document;\nexport const HTML = ROOT.documentElement;\nexport const BODY = ROOT.body;\n\nexport const INSERT_BEFORE = 'beforebegin';\nexport const INSERT_AFTER = 'afterend';\n\nexport const START_EVENT = 'start';\nexport const MOVE_EVENT = 'move';\nexport const SORT_EVENT = 'sort';\nexport const CHANGE_EVENT = 'change';\nexport const END_EVENT = 'end';\n\nexport const { floor, abs } = Math;\n\n\nexport const METHODS = {\n    x: {\n\t\t_scrollProperty: 'scrollLeft',\n\t\t_scrollDimension: 'scrollWidth',\n\t\t_lowerBound: 'left',\n\t\t_upperBound: 'right',\n\t\t_dimension: 'width'\n\t},\n\t\n\ty: {\n\t\t_scrollProperty: 'scrollTop',\n\t\t_scrollDimension: 'scrollHeight',\n\t\t_lowerBound: 'top',\n\t\t_upperBound: 'bottom',\n\t\t_dimension: 'height'\n\t}\n}","/**\n * Iterate in an object, stop and return false if callback function returns true.\n *\n * @param {Object} object - Any object.\n * @param {CallableFunction} fn - Any Callback function.\n * @returns {Boolean}\n */\nexport const objectIterator = (object, fn) => {\n    for (const key in object) {\n        if (Object.hasOwnProperty.call(object, key)) {\n            fn(object[key], key);\n        }\n    }\n}\n\n/**\n * Merges two or more objects together into the target object.\n *\n * @param {Object} target - Object that will receive the new properties.\n * @param  {...Object} sources - Objects containing additional properties to merge in.\n * @returns {Object}\n */\nexport const merge = (target, ...sources) => Object.assign(target, ...sources);\n\n\n/**\n * Checks if a value is an object.\n *\n * @param {any} value - Value to check if it's an object.\n * @returns {Boolean}\n */\nexport const isObject = value => typeof value === 'object' && value != null && ! Array.isArray(value);","export const defaults = {\n    /**\n     * Object with x, y properties,\n     * drag items from the same position, x and y represent the coordinates,\n     * relative to the dragged item's top left corner, x and y can be,\n     * numbers or percentages, e.g. { x: '50%' } to center it horizontally.\n     *\n     * @type {Object}\n     */\n    dragFrom: {},\n\n    /**\n     * Set the cursor while dragging an item (CSS cursor property).\n     *\n     * @type {String}\n     */\n    cursor: '',\n\n    /**\n     * Adds a box shadow to the dragged item.\n     *\n     * @type {Boolean}\n     */\n    elevation: true,\n\n    /**\n     * Adds class(es) to the dragged item, theose classes,\n     * will be removed when the item is dropped.\n     *\n     * @type {String}\n     */\n    active: '',\n\n    /**\n     * Add classes to the placeholder (The empty slot).\n     *\n     * @type {String}\n     */\n    placeholder: '',\n\n    /**\n     * A Selector or an Element, use it as a drag area within the item.\n     *\n     * @type {String|Element}\n     */\n    dragHandle: '',\n\n    /**\n     * Lock movement to only one axis 'x' or 'y'.\n     *\n     * @type {String}\n     */\n    axis: '',\n\n    /**\n     * Disable/Enable sorting.\n     *\n     * @type {Boolean}\n     */\n    disabled: false,\n\n    /**\n     * Apply opacity to the dragged item (during dragging),\n     * value must be between 0 and 1 exclusive\n     *\n     * @type {Number}\n     */\n    opacity: 1,\n\n    /**\n     * Auto scroll while dragging an item, to show out of viewport items.\n     *\n     * @type {Boolean}\n     */\n    autoScroll: true,\n\n    /**\n     * Right to Left direction.\n     *\n     * @type {Boolean}\n     */\n    rtl: false,\n}","export const TARTIB_CLASSNAME = 'tartib';\nexport const ITEM_CLASSNAME = 'tartib__item';\nexport const ITEM_SELECTOR = '.' + ITEM_CLASSNAME;\nexport const ITEM_DRAGGED_CLASSNAME = ITEM_CLASSNAME + '--dragged';\nexport const PLACEHOLDER_CLASSNAME = 'tartib__placeholder';\nexport const ELEVATION_CLASSNAME = 'tt-elevation';\nexport const ACTIVE_CLASSNAME = 'tt-active';","import { INSERT_AFTER, INSERT_BEFORE, METHODS } from \"../constants\";\n\n/**\n * Gets placeholder's next position.\n *\n * @param {Object} targetBounds        - Target element bounding rect object.\n * @param {Number} mouseStart          - Mouse starting position.\n * @param {Number} mousePosition       - Mouse position.\n * @param {Boolean} isVertical         - Indicate whether the sorting is vertically or horizontally.\n * @param {String|undefined} placeholderPosition - Used for the diagonal positionning, the position of the placeholder in the other axis.\n * @returns {String}\n */\nexport const getPlaceholderPosition = (targetBounds, mouseStart, mousePosition, axis, isRTL, placeholderPosition) => {\n\n    let position;\n    let methods = METHODS[axis];\n\n    // This indicates whether the mouse intersected the,\n    // next element half (50% of its dimension) width or height.\n    let nextElMouseIntersection = mousePosition > targetBounds[axis] + targetBounds[methods._dimension] * 0.5;\n    // Mouse movement, whether if its moving down or to the right.\n    let movement = mouseStart[axis] < mousePosition;\n\n    // Mouse is moving down or to the right.\n    // Otherwise, mouse is moving up or to the left.\n    if (movement) {\n        if (nextElMouseIntersection || placeholderPosition) {\n            position = isRTL ? INSERT_BEFORE : INSERT_AFTER;\n        }\n    } else {\n        // Mouse intersected the previous element.\n        if (! nextElMouseIntersection || placeholderPosition) {\n            position = isRTL ? INSERT_AFTER : INSERT_BEFORE;\n        }\n    }\n\n    return position;\n}","/**\n * Checks if a value is a string.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isString = value => typeof value === 'string';\n\n/**\n * Disables/Enables Tartib.\n *\n * @param {Object} tartib - Instance.\n * @param {Boolean} disabled - A state to set.\n */\nexport const setDisable = (tartib, disabled) => {\n    tartib.config.disabled = disabled;\n}","import { ROOT } from \"../constants\";\nimport { objectIterator } from \"./object\";\nimport { isString } from \"./util\";\n\n/**\n * Gets a DOM element.\n *\n * @param {String|Element} ref - CSS selector or DOM element.\n * @param {Element} context - Element to search from.\n * @param {Boolean} all - Get all elements.\n * @returns {NodeList|Element|null}\n */\nexport const getElement = (ref, context, all) => isString(ref) ? ref && (context || ROOT)['querySelector' + (all ? 'All' : '')](ref)\n                                : ref instanceof Element ? ref\n                                : null;\n\n\n/**\n * Gets element bounds.\n *\n * @param {HTMLElement} el Element.\n * @returns {Object}\n */\nexport const getBounds = (el) => el && el.getBoundingClientRect();\n\n/**\n * Gets an element's parent.\n *\n * @param {Element} el - Any html element.\n * @returns {Element}\n */\nexport const getParent = el => el.parentElement;\n\n/**\n * Adds inline styles to an element.\n *\n * @param {Element} el - Any Element.\n * @param {Object} styles - Inline styles.\n */\nexport const inlineStyles = (el, styles) => {\n\n    if (styles) {\n        objectIterator(styles, (value, property) => {\n            el.style[property] = value;\n        });\n    } else {\n        el.style = null;\n    }\n}\n\n/**\n * Updates element's classes.\n *\n * @param {Element} el - Any DOM Element.\n * @param {String|Array} classes - Element classes.\n * @param {Boolean} remove - Whether to remove classes.\n */\nconst updateList = (el, classes, remove) => {\n\n    if (classes) {\n        if (isString(classes)) {\n            classes = [classes];\n        }\n    \n        classes.forEach(classname => {\n            isString(classname) && classname.split(/\\s+/).forEach(cls => {\n                if (cls) {\n                    el.classList[remove ? 'remove' : 'add'](cls);\n                }\n            });\n        });\n    }\n}\n\n/**\n * Adds/Removes classes.\n *\n * @param {Element} el - Any DOM Element.\n * @returns {Object}\n */\nexport const classList = (el) => ({\n    /**\n     * Adds classes to el classList.\n     *\n     * @param {Array|String} classes - Classes to add.\n     */\n    _add(classes) {\n        this._classes = classes;\n        updateList(el, classes);\n    },\n\n    /**\n     * Removes all added classes from el classList.\n     */\n    _remove() {\n        updateList(el, this._classes, true);\n    }\n});","import { abs, METHODS } from \"../constants\";\n\n/**\n * Scrolls ancestors that hides parts of the sortable list.\n *\n * @param {Element} el - Scrollable element.\n * @param {Object} elBounds - Scrollable element bounding rect.\n * @param {Object} itemBounds - Item's bounding rect.\n * @param {Boolean} isVertical - Indicates whether to scroll Vertically or horizontally.\n * @param {Boolean} isRTL - Indicates whether the list is in RTL direction.\n */\nexport const scroll = (el, elBounds, itemBounds, axis, isRTL) => {\n\n    /**\n     * All these variables are property names (methods), depending on the axis.\n     */\n    let { _lowerBound, _upperBound, _scrollProperty, _scrollDimension, _dimension } = METHODS[axis];\n\n    /**\n     * Scroll direction (top | right | bottom | left).\n     * @type {String}\n     */\n    let scrollTowards;\n    let scrollAmount = abs(el[_scrollProperty]);\n    let isScrolled = scrollAmount > 0;\n    let isFullScrolled = scrollAmount < el[_scrollDimension] - elBounds[_dimension];\n\n    // Scroll up or left.\n    if (( isRTL ? isFullScrolled : isScrolled) && itemBounds[_lowerBound] < elBounds[_lowerBound]) {\n        scrollTowards = _lowerBound;\n        // Scroll bottom or right.\n    } else if ((isRTL ? isScrolled : isFullScrolled) && itemBounds[_upperBound] > elBounds[_upperBound]) {\n        scrollTowards = _upperBound;\n    }\n\n    if (scrollTowards) {\n        el[_scrollProperty] += itemBounds[scrollTowards] - elBounds[scrollTowards];\n    }\n}","import { METHODS } from \"../constants\";\nimport { getBounds } from \"./dom\";\nimport { isObject, objectIterator } from \"./object\";\nimport { isString } from \"./util\";\n\n\n/**\n * Gets drag from point.\n *\n * @param {Element} item    - Dragged item.\n * @param {Ojbect} dragFrom - Pointer position relative to the dragged item.\n * @param {Object} pointer    - Pointer position.\n * @param {Element} handle - Drag handle.\n * @param {Boolean} isRTL - Whether Scrollable is in rtl direction.\n * @returns {Object}\n */\nexport const getDragPoint = (item, dragFrom, pointer, handle, isRTL) => {\n    dragFrom = isObject(dragFrom) ? dragFrom : {};\n\n    let bounds = getBounds(handle || item);\n    let itemBounds = handle ? getBounds(item) : bounds;\n    let point = {};\n    let dragVal;\n\n    objectIterator(pointer, (val, axis) => {\n        dragVal = dragFrom[axis];\n\n        if (dragVal === '' || isNaN(dragVal)) {\n            // If it's a percentage.\n            if (isString(dragVal) && /^\\d*.?\\d+\\s*%$/.test(dragVal.trim())) {\n                dragVal = parseFloat(dragVal) * bounds[METHODS[axis]._dimension] / 100;\n            } else {\n                // Invalid value.\n                dragVal = null;\n            }\n        } else {\n            // Number or a String number, convert it to number.\n            dragVal *= 1;\n        }\n\n\n        if (dragVal != null) {\n\n            if (isRTL && axis === 'x') {\n                dragVal = bounds.width - dragVal;\n            }\n\n            dragVal += bounds[axis];\n        } else {\n            dragVal = val;\n        }\n\n        point[axis] = dragVal - itemBounds[axis];\n    });\n\n    return point;\n}","import { INSERT_AFTER, INSERT_BEFORE } from \"../constants\";\n\n/**\n * Inserts a placeholder element into the list.\n *\n * @param {String} where - Where to insert the element.\n * @param {Element} reference - Insert placeholder element before or after this element. \n * @param {Element} element - Element to insert. \n */\nexport const insertPlaceholder = (where, reference, placeholder) => {\n    let sibling = {\n        [INSERT_BEFORE]: 'previous',\n        [INSERT_AFTER]: 'next'\n    }\n\n    // Check if the element is not already exist.\n    if (reference[sibling[where] + 'ElementSibling'] !== placeholder) {\n        reference.insertAdjacentElement(where, placeholder);\n    }\n}","import { ACTIVE_CLASSNAME, ELEVATION_CLASSNAME, ITEM_DRAGGED_CLASSNAME, PLACEHOLDER_CLASSNAME } from \"../utils/classes\";\nimport { getPlaceholderPosition } from \"../placeholder/position\";\nimport { autoScroll } from \"../scroll/autoScroll\";\nimport { classList, getBounds, getElement, getParent, inlineStyles } from \"../utils/dom\";\nimport { getDragPoint } from \"../utils/dragPoint\";\nimport { EventBinder } from \"./events/binder\";\nimport { getScrollableAncestors } from \"../scroll/scrollable\";\nimport { insertPlaceholder } from \"../placeholder/insert\";\nimport { CHANGE_EVENT, END_EVENT, floor, HTML, INSERT_BEFORE, METHODS, MOVE_EVENT, ROOT, SORT_EVENT, START_EVENT } from \"../constants\";\nimport { List } from \"./list\";\n\n/**\n * Sorts a list by dragging its items.\n *\n * @param {Tartib} tartib - Instance.\n */\nexport const sortable = (tartib) => {\n\n    const { el, config, _e: { _emit } } = tartib;\n\n    /**\n     * List.\n     */\n    const { _getItem, _getItems } = List(el);\n\n    /**\n     * Event binder methods.\n     */\n    const { _bind, _clear } = EventBinder();\n\n    /**\n     * Dragged List Item.\n     *\n     * @type {Element}\n     */\n    let draggedItem;\n\n    /**\n     * Placeholder Item.\n     *\n     * @type {Element}\n     */\n    let placeholder;\n\n    /**\n     * List scrollable ancestors elements.\n     *\n     * @type {Array<Element>}\n     */\n    let scrollableAncestors;\n\n    /**\n     * Elements classLists.\n     */\n    let classLists = {\n        _list: classList(el),\n    }\n\n    /**\n     * Dragged Item Bounding rect.\n     *\n     * @type {DOMRect}\n     */\n    let itemBounds;\n\n    /**\n     * Array of list items.\n     *\n     * @type {Array<Element>}\n     */\n    let startList;\n\n    /**\n     * Start pointer coordinates.\n     *\n     * @type {Object} \n     */\n    let startPoint = {}\n\n    /**\n     * Drag at coordinates.\n     *\n     * @type {Object}\n     */\n    let dragPoint = {}\n\n    /**\n     * Event Object Data.\n     *\n     * @type {Object}\n     */\n    let eventObject;\n\n    /**\n     * Indicates whether a dragged item start moving.\n     */\n    let startMoving = false;\n\n    /**\n     * Indicates whether an item is dragged.\n     */\n    let isDragging = false;\n\n    /**\n     * Right To Left Direction.\n     */\n    let isRTL;\n\n    /**\n     * Lock movement to one axis.\n     *\n     * @type {Object}\n     */\n    let axisLock;\n\n    /**\n     * Starts dragging.\n     *\n     * @param {Event} e - Mousedown.\n     */\n    const dragStart = e => {\n\n        let { dragHandle, dragFrom, disabled, autoScroll, rtl, axis, cursor } = config;\n        let { target, pointerId, clientX, clientY, button } = e;\n\n        \n        draggedItem = _getItem(target);\n\n        /**\n         * Exit, if disabled or pointer down wasn't in a list item,\n         * or in a drag handle.\n         * or it's not the main button in case of a mouse click.\n         */\n        if (disabled || !draggedItem || button || (dragHandle && target !== getElement(dragHandle, draggedItem))) {\n            return;\n        }\n\n        isRTL = rtl;\n        axisLock = {\n            x: axis !== 'y',\n            y: axis !== 'x'\n        }\n\n        target.releasePointerCapture(pointerId);\n        placeholder = draggedItem.cloneNode();\n        placeholder.id = '';\n        startList = _getItems();\n\n\n        classLists._item = classList(draggedItem);\n        classLists._placeholder = classList(placeholder);\n\n        classLists._list._add(ACTIVE_CLASSNAME);\n        inlineStyles(HTML, { cursor });\n\n        startPoint = {\n            x: clientX,\n            y: clientY\n        }\n\n        eventObject = {\n            el,\n            x: 0,\n            y: 0,\n            target: draggedItem,\n            relatedTarget: null,\n            placeholder,\n            items: startList,\n            getData(attribute) {\n                return _getAttributeMap(attribute, this.items);\n            }\n        }\n\n        dragPoint = getDragPoint(draggedItem, dragFrom, startPoint, dragHandle ? target : null, isRTL);\n        scrollableAncestors = autoScroll ? getScrollableAncestors(el) : [];\n        isDragging = true;\n    }\n\n    /**\n     * moves an item.\n     *\n     * @param {Event} e - Mousemove.\n     */\n    const dragMove = e => {\n        if (isDragging) {\n            let { target: relatedTarget, clientX, clientY } = e;\n            let data;\n\n            if (! startMoving) {\n                setItemPosition(startPoint.x, startPoint.y, {});\n\n                let { elevation, placeholder: placeholderClassname, opacity, active } = config;\n                let { width, height, x, y } = getBounds(draggedItem);\n\n                height += 'px';\n                width += 'px';\n                inlineStyles(draggedItem, {\n                    width,\n                    height,\n                    opacity: opacity > 0 && opacity < 1 ? opacity : false,\n                });\n                inlineStyles(placeholder, { height });\n\n                /**\n                 * Fire start event.\n                 */\n                _emit(START_EVENT, eventObject, { x, y });\n\n                classLists._item._add([ITEM_DRAGGED_CLASSNAME, elevation && ELEVATION_CLASSNAME, active]);\n                classLists._placeholder._add(placeholderClassname || PLACEHOLDER_CLASSNAME);\n\n                insertPlaceholder(INSERT_BEFORE, draggedItem, placeholder);\n                startMoving = true;\n            }\n\n            /**\n             * Move item.\n             */\n            setItemPosition(clientX, clientY, axisLock);\n\n            itemBounds = getBounds(draggedItem);\n\n            data = {\n                x: itemBounds.x,\n                y: itemBounds.y\n            }\n\n            /**\n             * Fire move event.\n             */\n            _emit(MOVE_EVENT, eventObject, data, { relatedTarget });\n\n            /**\n             * Scroll to view where to drop.\n             */\n            autoScroll(scrollableAncestors, itemBounds, isRTL);\n\n            relatedTarget = _getItem(relatedTarget);\n\n            if (el.contains(relatedTarget) && relatedTarget !== placeholder) {\n                let bounds = getBounds(relatedTarget);\n                let { top, right, bottom, left } = getBounds(placeholder);\n                let movingVertically = clientX <= floor(right) && clientX >= floor(left) && axisLock.y;\n                let movingHorizontally = clientY <= floor(bottom) && clientY >= floor(top) && axisLock.x;\n                let position;\n\n                // Sorting item diagonally.\n                if (! movingHorizontally && ! movingVertically && (axisLock.x && axisLock.y)) {\n                    // Get position horizontally, pass it to the vertical position.\n                    position = getPlaceholderPosition(bounds, startPoint, clientX, 'x', isRTL);\n                    position = getPlaceholderPosition(bounds, startPoint, clientY, 'y', false, position);\n                } else {\n                    // Sorting item vertically.\n                    if (! movingHorizontally) {\n                        position = getPlaceholderPosition(bounds, startPoint, clientY, 'y', false);\n                    }\n\n                    // Sorting item horizontally.\n                    if (! movingVertically) {\n                        position = getPlaceholderPosition(bounds, startPoint, clientX, 'x', isRTL);\n                    }\n                }\n\n                if (position) {\n                    insertPlaceholder(position, relatedTarget, placeholder);\n                    startPoint.y = clientY;\n                    startPoint.x = clientX;\n\n                    /**\n                     * Fire sort event.\n                     */\n                    _emit(SORT_EVENT, eventObject, data, { \n                        relatedTarget,\n                        items: _getItems(),\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Ends dragging.\n     *\n     * @param {Event} e - Mouseup.\n     */\n    const dragEnd = e => {\n        if (isDragging) {\n\n            if (getParent(placeholder)) {\n                el.replaceChild(draggedItem, placeholder);\n                placeholder = null;\n            }\n\n            let endList = _getItems();\n            let data = {\n                placeholder,\n                items: endList\n            }\n\n            inlineStyles(draggedItem);\n            inlineStyles(HTML, { cursor: '' });\n\n            classLists._item._remove();\n            classLists._list._remove();\n\n            if (startList.some((item, index) => item !== endList[index])) {\n                /**\n                 * Fire change event.\n                 */\n                _emit(CHANGE_EVENT, eventObject, data);\n            }\n\n            if (startMoving) {\n                /**\n                 * Fire end event.\n                 */\n                _emit(END_EVENT, eventObject, data);\n            }\n\n            isDragging = startMoving = false;\n        }\n    }\n\n    /**\n     * Sets item position.\n     *\n     * @param {Number} x - Mouse X coordinate.\n     * @param {Number} y - Mouse Y coordinate.\n     * @param {Object} axis - Axis option.\n     */\n    const setItemPosition = (x, y, axis) => {\n\n        if (isRTL) {\n            x -= HTML[METHODS.x._scrollProperty];\n        }\n\n\n        if (axis.y) {\n            draggedItem.style.top = y - dragPoint.y + 'px';\n        }\n\n        if (axis.x) {\n            draggedItem.style.left = x - dragPoint.x + 'px';\n        }\n    }\n\n\n    /**\n     * Gets an array, each value is an attribute value of a list item.\n     *\n     * @param {String} attribute - Element attribute name.\n     * @param {Array<Element>} items - Sortable list items.\n     * @returns {Array}\n     */\n    const _getAttributeMap = (attribute, items) => items.map(item => item.getAttribute(attribute || 'id'));\n\n    /**\n     * Events.\n     */\n    _bind(el, 'pointerdown', dragStart);\n    _bind(ROOT, 'pointermove', dragMove);\n    _bind(ROOT, 'pointerup', dragEnd);\n    _bind(ROOT, 'pointercancel', e => {\n        isDragging = startMoving = false;\n    });\n\n    return {\n        _clear,\n        _getAttributeMap,\n        _getItems\n    }\n}","import { ITEM_SELECTOR, PLACEHOLDER_CLASSNAME } from \"../utils/classes\";\nimport { getElement } from \"../utils/dom\";\n\n/**\n * Sortable list.\n *\n * @param {Element} el - Sortable List element.\n * @returns {Object}\n */\nexport const List = el => ({\n\n    /**\n     * Gets List item.\n     *\n     * @param {Element} target - Event Target.\n     * @returns {Element|null}\n     */\n    _getItem: target => target.closest(ITEM_SELECTOR),\n\n    /**\n     * Gets sortable list items.\n     *\n     * @param {Element} list - Sortabale list.\n     * @returns {Array<Element>}\n     */\n    _getItems() {\n         let nodeList = getElement(ITEM_SELECTOR, el, true);\n         let items = [];\n         let length = nodeList.length;\n\n         for (let i = 0; i < length; i++) {\n             const element = nodeList[i];\n             // Exclude placeholder item.\n             if (! element.classList.contains(PLACEHOLDER_CLASSNAME)) {\n                 items.push(element);\n             }\n         }\n         return items;\n     }\n\n})","/**\n * Binds/Unbinds events listeners.\n *\n * @returns {Object}\n */\nexport const EventBinder = () => {\n    const listeners = [];\n\n    /**\n     * Binds/Unbinds an event listener.\n     *\n     * @param {Array} listener - Event listener array.\n     * @param {Boolean} unbind - Indicates whether to unbind the listener or not.\n     */\n    const binder = (listener, unbind) => {\n        listener[0][(unbind ? 'remove': 'add') + 'EventListener'](listener[1], listener[2]);\n    }\n\n    return {\n        /**\n         * Registers and Adds an event listener.\n         */\n        _bind(target, type, handler) {\n            if (target) {\n                let listener = [target, type, handler];\n                binder(listener);\n                listeners.push(listener);\n            }\n        },\n\n        /**\n         * Removes all events listeners.\n         */\n        _clear() {\n            listeners.forEach(listener => {\n                binder(listener, true);\n            });\n        }\n    }\n}","import { BODY, HTML } from \"../constants\";\nimport { getBounds, getParent } from \"../utils/dom\";\n\n/**\n * Gets scrollable ancestors elements.\n *\n * @param {Element} el - Element to get its scrollable ancestors.\n * @returns {Array}\n */\nexport const getScrollableAncestors = (el) => {\n    let scrollableAncestors = [];\n    let elHeight = el.scrollHeight;\n    let elWidth = el.scrollWidth;\n\n    while (el !== null) {\n        let overflow = getComputedStyle(el).overflow;\n        let { width, height } = getBounds(el);\n        let isRoot = el === HTML;\n\n        if (isRoot) {\n            height = HTML.clientHeight;\n        }\n\n        if (\n            (overflow === 'auto' || overflow === 'scroll' || (isRoot && overflow === 'visible'))\n            &&\n            (height < elHeight || width < elWidth)\n            &&\n            el !== BODY\n        ) {\n            scrollableAncestors.push(el);\n        }\n\n        el = getParent(el);\n    }\n\n    return scrollableAncestors;\n}","import { HTML } from \"../constants\";\nimport { getBounds } from \"../utils/dom\";\nimport { scroll } from \"./scroll\";\n\n/**\n * Auto scrolls parent scrollables that hide part of the list, when dragging\n * a list item.\n *\n * @param {Array} scrollables - Scrollable elements.\n * @param {DOMRect} itemBounds - List item bounding rect.\n * @param {Boolean} isRTL - Indicates if the list is in RTL direction.\n */\nexport const autoScroll  = (scrollables, itemBounds, isRTL) => {\n    scrollables.forEach(scrollable => {\n        let bounds = getBounds(scrollable);\n\n        if (scrollable === HTML) {\n            let domHeight = HTML.clientHeight;\n            let width = bounds.width;\n\n            bounds = {\n                top: 0,\n                left: 0,\n                right: width,\n                bottom: domHeight,\n                height: domHeight,\n                width\n            }\n        }\n\n        // Scroll for each axis.\n        scroll(scrollable, bounds, itemBounds, 'x', isRTL);\n        scroll(scrollable, bounds, itemBounds, 'y', false);\n    });\n}\n\n","import '../sass/tartib.scss';\nimport { EventListener } from './core/events/listener';\nimport { defaults } from './defaults';\nimport { sortable } from './core/sortable';\nimport { merge, objectIterator } from './utils/object';\nimport { setDisable } from './utils/util';\nimport { getElement } from './utils/dom';\n\nexport default class Tartib {\n\n    /**\n     * Tartib version.\n     */\n    static version = VERSION;\n\n    /**\n     * Tartib defaults.\n     */\n    static defaults = defaults;\n\n    /**\n     * Constructor.\n     *\n     * @param {String|Element} reference - List element or its selector.\n     * @param {Object} options - Tartib options.\n     */\n    constructor(reference, options) {\n        const tartib = this;\n        tartib.el = getElement(reference);\n        tartib.config = merge({}, Tartib.defaults, options);\n        tartib._e = EventListener();\n        tartib._s = sortable(tartib);\n    }\n\n    /**\n     * Sets options.\n     *\n     * @param {Object} options - Tartib new options.\n     */\n    setOptions(options) {\n        merge(this.config, options);\n    }\n\n    /**\n     * Attaches an event listener.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    on(type, handler) {\n        this._e._on(type, handler);\n    }\n\n    /**\n     * Removes an event listener.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    off(type, handler) {\n        this._e._off(type, handler);\n    }\n\n    /**\n     * Gets an array of each item's attribute value.\n     *\n     * @param {String} attribute - Element attribute name.\n     * @returns {Array<String>}\n     */\n    getData(attribute) {\n        let sortable = this._s;\n        return sortable._getAttributeMap(attribute, sortable._getItems());\n    }\n\n    /**\n     * Disable sorting.\n     */\n    disable() {\n        setDisable(this, true);\n    }\n\n    /**\n     * Enable sorting.\n     */\n    enable() {\n        setDisable(this, false);\n    }\n\n    /**\n     * Removes this instance functionality.\n     */\n    destroy() {\n        const tartib = this;\n\n        tartib._s._clear();\n        objectIterator(tartib, (val, prop) => {\n            delete tartib[prop];\n        });\n    }\n}","import { CHANGE_EVENT, END_EVENT, MOVE_EVENT, SORT_EVENT, START_EVENT } from \"../../constants\";\nimport { merge, objectIterator } from \"../../utils/object\";\n\n/**\n * Tartib events.\n *\n * @returns {Object}\n */\nexport const EventListener = () => {\n\n    /**\n     * Tartib event handlers.\n     */\n    const handlers = {\n        [START_EVENT]: [],\n        [MOVE_EVENT]: [],\n        [SORT_EVENT]: [],\n        [CHANGE_EVENT]: [],\n        [END_EVENT]: []\n    }\n\n    return {\n        /**\n         * Emits an event.\n         *\n         * @param {String} type - Event type.\n         * @param  {Element|Object} source - Event Source.\n         */\n        _emit(type, ...args) {\n            handlers[type].forEach(handler => {\n                handler(merge({}, { type }, ...args));\n            });\n        },\n\n        /**\n         * Adds an event listener.\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        _on(type, handler) {\n            handlers[type] && handlers[type].push(handler);\n        },\n\n        /**\n         * Removes event listener(s).\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        _off(type, handler) {\n            let handlersArray = handlers[type];\n\n            if (handlersArray) {\n                // Remove the handler if it's specified,\n                // Remove all handlers of this event if handler is omitted.\n                handlers[type] = handler ? handlersArray.filter(attachedHanlder => attachedHanlder !== handler) : [];\n            } else if (type === null) {\n                objectIterator(handlers, (arr, type) => {\n                    handlers[type] = [];\n                });\n            }\n\n        }\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ROOT","document","HTML","documentElement","BODY","body","INSERT_BEFORE","INSERT_AFTER","START_EVENT","MOVE_EVENT","SORT_EVENT","CHANGE_EVENT","floor","abs","Math","METHODS","x","_scrollProperty","_scrollDimension","_lowerBound","_upperBound","_dimension","y","objectIterator","object","fn","merge","target","sources","assign","defaults","dragFrom","cursor","elevation","active","placeholder","dragHandle","axis","disabled","opacity","autoScroll","rtl","ITEM_SELECTOR","PLACEHOLDER_CLASSNAME","getPlaceholderPosition","targetBounds","mouseStart","mousePosition","isRTL","placeholderPosition","position","methods","nextElMouseIntersection","isString","value","setDisable","tartib","config","getElement","ref","context","all","Element","getBounds","el","getBoundingClientRect","getParent","parentElement","inlineStyles","styles","property","style","updateList","classes","remove","forEach","classname","split","cls","classList","_add","this","_classes","_remove","scroll","elBounds","itemBounds","scrollTowards","scrollAmount","isScrolled","isFullScrolled","getDragPoint","item","pointer","handle","Array","isArray","dragVal","bounds","point","val","isNaN","test","trim","parseFloat","width","insertPlaceholder","where","reference","insertAdjacentElement","sortable","_e","_emit","_getItem","_getItems","closest","nodeList","items","length","i","element","contains","push","List","_bind","_clear","listeners","binder","listener","unbind","type","handler","EventBinder","draggedItem","scrollableAncestors","startList","eventObject","axisLock","classLists","_list","startPoint","dragPoint","startMoving","isDragging","setItemPosition","top","left","_getAttributeMap","attribute","map","getAttribute","e","pointerId","clientX","clientY","button","releasePointerCapture","cloneNode","id","_item","_placeholder","relatedTarget","getData","elHeight","scrollHeight","elWidth","scrollWidth","overflow","getComputedStyle","height","isRoot","clientHeight","getScrollableAncestors","data","placeholderClassname","ITEM_CLASSNAME","scrollables","scrollable","domHeight","right","bottom","movingVertically","movingHorizontally","replaceChild","endList","some","index","Tartib","VERSION","constructor","options","handlers","args","_on","_off","handlersArray","filter","attachedHanlder","arr","EventListener","_s","setOptions","on","off","disable","enable","destroy"],"sourceRoot":""}