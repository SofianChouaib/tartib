{"version":3,"file":"js/tartib.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,SAAU,GAAIH,GACK,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,GAClB,CATD,CASGK,MAAM,I,mBCRT,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,4BCA3E,MAAMI,EAAOC,SACPC,EAAOF,EAAKG,gBACZC,EAAOJ,EAAKK,KAEZC,EAAgB,cAChBC,EAAe,WAEfC,EAAc,QACdC,EAAa,OACbC,EAAa,OACbC,EAAe,UAGf,MAAEC,EAAF,IAASC,GAAQC,KAGjBC,EAAU,CACnBC,EAAG,CACLC,EAAiB,aACjBC,EAAkB,cAClBC,EAAa,OACbC,EAAa,QACbC,EAAY,SAGbC,EAAG,CACFL,EAAiB,YACjBC,EAAkB,eAClBC,EAAa,MACbC,EAAa,SACbC,EAAY,WCvBDE,EAAiB,CAACC,EAAQC,KACnC,IAAK,MAAMpC,KAAOmC,EACVjC,OAAOO,eAAeC,KAAKyB,EAAQnC,IACnCoC,EAAGD,EAAOnC,GAAMA,EAEvB,EAUQqC,EAAQ,CAACC,KAAWC,IAAYrC,OAAOsC,OAAOF,KAAWC,GCtBzDE,EAAW,CAOpBC,SAAU,CAAC,EAOXC,OAAQ,GAORC,WAAW,EAQXC,OAAQ,GAORC,YAAa,GAObC,WAAY,GAOZC,MAAM,EAONC,UAAU,EAOVC,SAAS,EAOTC,YAAY,EAOZC,KAAK,GC5EIC,EAAgB,gBAChBC,EAAyBC,wBACzBC,EAAsB,oBACtBC,EAAwB,sBCOxBC,EAAyB,CAACC,EAAcC,EAAYC,EAAeb,EAAMc,EAAOC,KAEzF,IAAIC,EACAC,EAAUvC,EAAQsB,GAIlBkB,EAA0BL,EAAgBF,EAAaX,GAA2C,GAAnCW,EAAaM,EAAQjC,GAiBxF,OAfe4B,EAAWZ,GAAQa,GAK1BK,GAA2BH,KAC3BC,EAAWF,EAAQ7C,EAAgBC,GAIjCgD,IAA2BH,IAC7BC,EAAWF,EAAQ5C,EAAeD,GAInC+C,CAAP,EC9BSG,EAAWC,GAA0B,iBAAVA,EAQ3BC,EAAa,CAACC,EAAQrB,KAC/BqB,EAAOC,OAAOtB,SAAWA,CAAzB,ECHSuB,EAAa,CAACC,EAAKC,EAASC,IAAQR,EAASM,GAAOA,IAAQC,GAAW/D,GAAM,iBAAmBgE,EAAM,MAAQ,KAAKF,GAC9FA,aAAeG,QAAUH,EACzB,KASrBI,EAAaC,GAAOA,GAAMA,EAAGC,wBAQ7BC,EAAYF,GAAMA,EAAGG,cAQrBC,EAAe,CAACJ,EAAIK,KAEzBA,EACAjD,EAAeiD,GAAQ,CAACf,EAAOgB,KAC3BN,EAAGO,MAAMD,GAAYhB,CAArB,IAGJU,EAAGO,MAAQ,IACd,EAUCC,EAAa,CAACR,EAAIS,EAASC,KAEzBrB,EAASoB,KACTA,EAAU,CAACA,IAGfA,EAAQE,SAAQC,KACZA,EAAYvB,EAASuB,IAAcA,EAAUC,MAAM,QAEzCF,SAAQG,IACVA,GACAd,EAAGe,UAAUL,EAAS,SAAW,OAAOI,EAC3C,GAHL,GAHJ,EAiBSC,EAAYf,IAAM,CAM3BgB,EAAKP,GACDD,EAAWR,EAAIS,EAClB,EAODQ,EAAQR,GACJD,EAAWR,EAAIS,GAAS,EAC3B,ICtFQS,EAAS,CAAClB,EAAImB,EAAUC,EAAYlD,EAAMc,KAKnD,IAMIqC,GANA,EAAErE,EAAF,EAAeC,EAAf,EAA4BH,EAA5B,EAA6CC,EAA7C,EAA+DG,GAAeN,EAAQsB,GAOtFoD,EAAe5E,EAAIsD,EAAGlD,IACtByE,EAAaD,EAAe,EAC5BE,EAAiBF,EAAetB,EAAGjD,GAAoBoE,EAASjE,IAG9D8B,EAAQwC,EAAiBD,IAAeH,EAAWpE,GAAemE,EAASnE,GAC7EqE,EAAgBrE,GAERgC,EAAQuC,EAAaC,IAAmBJ,EAAWnE,GAAekE,EAASlE,KACnFoE,EAAgBpE,GAGhBoE,IACArB,EAAGlD,IAAoBsE,EAAWC,GAAiBF,EAASE,GAC/D,ECrBQI,EAAe,CAACC,EAAM9D,EAAU+D,EAASC,EAAQ5C,KPetCM,MOdpB1B,EPc8C,iBAA1B0B,EOdA1B,IPc+C,MAAT0B,GAAmBuC,MAAMC,QAAQxC,GOdhD,CAAC,EAAZ1B,EAEhC,IAGImE,EAHAC,EAASjC,EAAU6B,GAAUF,GAC7BN,EAAaQ,EAAS7B,EAAU2B,GAAQM,EACxCC,EAAQ,CAAC,EAkCb,OA/BA7E,EAAeuE,GAAS,CAACO,EAAKhE,KAC1B6D,EAAUnE,EAASM,GAEH,KAAZ6D,GAAkBI,MAAMJ,GAGpBA,EADA1C,EAAS0C,IAAY,iBAAiBK,KAAKL,EAAQM,QACzCC,WAAWP,GAAWC,EAAOpF,EAAQsB,GAAMhB,GAAc,IAGzD,KAId6E,GAAW,EAIA,MAAXA,GAEI/C,GAAkB,MAATd,IACT6D,EAAUC,EAAOO,MAAQR,GAG7BA,GAAWC,EAAO9D,IAElB6D,EAAUG,EAGdD,EAAM/D,GAAQ6D,EAAUX,EAAWlD,EAAnC,IAGG+D,CAAP,EC9CSO,EAAoB,CAACC,EAAOC,EAAW1E,KAO5C0E,EANU,CACV,CAACvG,GAAgB,WACjB,CAACC,GAAe,QAIEqG,GAAS,oBAAsBzE,GACjD0E,EAAUC,sBAAsBF,EAAOzE,EAC1C,ECFQ4E,EAAYpD,IAErB,MAAM,GAAEQ,EAAF,OAAMP,EAAQoD,IAAI,EAAEC,IAAYtD,GAKhC,EAAEuD,EAAF,EAAYC,GCdFhD,KAAM,CAQtB+C,EAAUvF,GAAUA,EAAOyF,QAAQ1E,GAQnCyE,IACK,IAAIE,EAAWxD,EAAWnB,EAAeyB,GAAI,GACzCmD,EAAQ,GACRC,EAASF,EAASE,OAEtB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQC,IAAK,CAC7B,MAAMC,EAAUJ,EAASG,GAEnBC,EAAQvC,UAAUwC,SAAS5E,IAC7BwE,EAAMK,KAAKF,EAElB,CACD,OAAOH,CACV,IDf8BM,CAAKzD,IAK/B,EAAE0D,EAAF,EAASC,GEvBQ,MACvB,MAAMC,EAAY,GAQZC,EAAS,CAACC,EAAUC,KACtBD,EAAS,IAAIC,EAAS,SAAU,OAAS,iBAAiBD,EAAS,GAAIA,EAAS,GAAhF,EAGJ,MAAO,CAIHJ,EAAMlG,EAAQwG,EAAMC,GAChB,IAAIH,EAAW,CAACtG,EAAQwG,EAAMC,GAC9BJ,EAAOC,GACPF,EAAUJ,KAAKM,EAClB,EAKDH,IACIC,EAAUjD,SAAQmD,IACdD,EAAOC,GAAU,EAAjB,GAEP,EAjBL,EFU0BI,GAO1B,IAAIC,EAOAnG,EAOAoG,EAOAC,EAOAjD,EAOAkD,EAqBAC,EAeAvF,EAOAwF,EApCAC,EAAa,CAAC,EAOdC,EAAY,CAAC,EAYbC,GAAc,EAKdC,GAAa,EAmBjB,MA0MMC,EAAkB,CAAChI,EAAGM,EAAGe,KAEvBc,IACAnC,GAAKd,EAAKa,EAAQC,EAAEC,IAIpBoB,EAAKf,IACLgH,EAAY5D,MAAMuE,IAAM3H,EAAIuH,EAAUvH,EAAI,MAG1Ce,EAAKrB,IACLsH,EAAY5D,MAAMwE,KAAOlI,EAAI6H,EAAU7H,EAAI,KAC9C,EAWCmI,EAAmB,CAACC,EAAW9B,IAAUA,EAAM+B,KAAIxD,GAAQA,EAAKyD,aAAaF,GAAa,QAShG,OAJAvB,EAAM1D,EAAI,eAvOQoF,IAEd,IAAI,WAAEnH,EAAF,SAAcL,EAAd,SAAwBO,EAAxB,WAAkCE,EAAlC,IAA8CC,EAA9C,KAAmDJ,GAASuB,GAC5D,OAAEjC,EAAF,UAAU6H,EAAV,QAAqBC,EAArB,QAA8BC,GAAYH,EAG9CjB,EAAcpB,EAASvF,GAMnBW,IAAagG,GAAgBlG,GAAcT,IAAWkC,EAAWzB,EAAYkG,KAIjFnF,EAAQV,EACRkG,EAAW,CACP3H,EAAY,MAATqB,EACHf,EAAY,MAATe,GAGPV,EAAOgI,sBAAsBH,GAC7BrH,EAAcmG,EAAYsB,YAC1BzH,EAAY0H,GAAK,GACjBpB,EAAYtB,IAEZqB,EAAgBtD,EAAUoD,GAE1BM,EAAa,CACT5H,EAAGyI,EACHnI,EAAGoI,GAGPhB,EAAc,CACVvE,KACAnD,EAAG,EACHM,EAAG,EACHK,OAAQ2G,EACRwB,cAAe,KACf3H,cACAmF,MAAOmB,EACPsB,QAAQX,GACJ,OAAOD,EAAiBC,EAAWY,KAAK1C,MAC3C,GAGLuB,EAAYjD,EAAa0C,EAAavG,EAAU6G,EAAYxG,EAAaT,EAAS,KAAMwB,GACxFoF,EAAsB/F,EG/JS2B,KACnC,IAAIoE,EAAsB,GACtB0B,EAAW9F,EAAG+F,aACdC,EAAUhG,EAAGiG,YAEjB,KAAc,OAAPjG,GAAa,CAChB,IAAIkG,EAAWC,iBAAiBnG,GAAIkG,UAChC,MAAE3D,EAAF,OAAS6D,GAAWrG,EAAUC,GAC9BqG,EAASrG,IAAOjE,EAEhBsK,IACAD,EAASrK,EAAKuK,eAIA,SAAbJ,GAAoC,WAAbA,GAA0BG,GAAuB,YAAbH,KAE3DE,EAASN,GAAYvD,EAAQyD,IAE9BhG,IAAO/D,GAEPmI,EAAoBZ,KAAKxD,GAG7BA,EAAKE,EAAUF,EAClB,CAED,OAAOoE,CAAP,EHoIuCmC,CAAuBvG,GAAM,GAChE4E,GAAa,EAAb,IAuLJlB,EAAM7H,EAAM,eA/KKuJ,IACb,GAAIR,EAAY,CACZ,IACI4B,GADEhJ,OAAQmI,EAAV,QAAyBL,EAAzB,QAAkCC,GAAYH,EAGlD,IAAMT,EAAa,CACfE,EAAgBJ,EAAW5H,EAAG4H,EAAWtH,EAAG,CAAC,GAE7C,IAAI,OAAEU,EAAF,UAAUC,EAAWE,YAAayI,EAAlC,QAAwDrI,EAAxD,OAAiEL,GAAW0B,GAC5E,MAAE8C,EAAF,OAAS6D,EAAT,EAAiBvJ,EAAjB,EAAoBM,GAAM4C,EAAUoE,GAExCiC,GAAU,KACV7D,GAAS,KAETnC,EAAa+D,EAAa,CACtB5B,QACA6D,SACAhI,QAASA,EAAU,GAAKA,EAAU,GAAIA,IAE1CgC,EAAarE,EAAM,CAAE8B,WACrBuC,EAAapC,EAAa,CAAEoI,WAE5BtD,EAAMzG,EAAakI,EAAa,CAAE1H,IAAGM,MAErCkH,EAAcrD,EAAK,CAACxC,EAAwBV,GAAaY,EAAqBX,IAE9EgD,EAAU/C,GAAagD,EAAKyF,GAAwB9H,GACpD6D,EAAkBrG,EAAegI,EAAanG,GAC9C2G,GAAc,CACjB,CA0BD,GArBAE,EAAgBS,EAASC,EAASf,GAElCpD,EAAarB,EAAUoE,GAEvBqC,EAAO,CACH3J,EAAGuE,EAAWvE,EACdM,EAAGiE,EAAWjE,GAMlB2F,EAAMxG,EAAYiI,EAAaiC,EAAM,CAAEb,kBInNxB,EAACe,EAAatF,EAAYpC,KACjD0H,EAAY/F,SAAQgG,IAChB,IAAI3E,EAASjC,EAAU4G,GAEvB,GAAIA,IAAe5K,EAAM,CACrB,IAAI6K,EAAY7K,EAAKuK,aACjB/D,EAAQP,EAAOO,MAEnBP,EAAS,CACL8C,IAAK,EACLC,KAAM,EACN8B,MAAOtE,EACPuE,OAAQF,EACRR,OAAQQ,EACRrE,QAEP,CAGDrB,EAAOyF,EAAY3E,EAAQZ,EAAY,IAAKpC,GAC5CkC,EAAOyF,EAAY3E,EAAQZ,EAAY,KAAK,EAA5C,GAnBJ,EJuNQ/C,CAAW+F,EAAqBhD,EAAYpC,GAE5C2G,EAAgB5C,EAAS4C,GAErB3F,EAAGuD,SAASoC,IAAkBA,IAAkB3H,EAAa,CAC7D,IAIIkB,EAJA8C,EAASjC,EAAU4F,IACnB,IAAEb,EAAF,MAAO+B,EAAP,OAAcC,EAAd,KAAsB/B,GAAShF,EAAU/B,GACzC+I,EAAmBzB,GAAW7I,EAAMoK,IAAUvB,GAAW7I,EAAMsI,IAASP,EAASrH,EACjF6J,EAAqBzB,GAAW9I,EAAMqK,IAAWvB,GAAW9I,EAAMqI,IAAQN,EAAS3H,GAIjFmK,IAAwBD,GAAqBvC,EAAS3H,GAAK2H,EAASrH,GAEtE+B,EAAWN,EAAuBoD,EAAQyC,EAAYa,EAAS,IAAKtG,GACpEE,EAAWN,EAAuBoD,EAAQyC,EAAYc,EAAS,KAAK,EAAOrG,KAGrE8H,IACF9H,EAAWN,EAAuBoD,EAAQyC,EAAYc,EAAS,KAAK,IAIlEwB,IACF7H,EAAWN,EAAuBoD,EAAQyC,EAAYa,EAAS,IAAKtG,KAIxEE,IACAsD,EAAkBtD,EAAUyG,EAAe3H,GAC3CyG,EAAWtH,EAAIoI,EACfd,EAAW5H,EAAIyI,EAKfxC,EAAMvG,EAAYgI,EAAaiC,EAAM,CACjCb,gBACAxC,MAAOH,MAGlB,CACJ,KAmFLU,EAAM7H,EAAM,aA3EIuJ,IACZ,GAAIR,EAAY,CAER1E,EAAUlC,KAAiBgC,IAC3BA,EAAGiH,aAAa9C,EAAanG,GAC7BA,EAAc,MAGlB,IAAIkJ,EAAUlE,IACVwD,EAAO,CACPxI,cACAmF,MAAO+D,GAGX9G,EAAa+D,GACb/D,EAAarE,EAAM,CAAE8B,OAAQ,KAE7BwG,EAAcpD,EAAQ,CAACzC,EAAwBE,EAAqBe,EAAO1B,SAEvEuG,EAAU6C,MAAK,CAACzF,EAAM0F,IAAU1F,IAASwF,EAAQE,MAIjDtE,EAAMtG,EAAc+H,EAAaiC,GAGjC7B,GAIA7B,EVzSS,MUySQyB,EAAaiC,GAGlC5B,EAAaD,GAAc,CAC9B,KA2CE,CACHhB,IACAqB,IACAhC,IAHJ,EK3VW,MAAMqE,EAKH,eAAGC,QAKF,gBAAG3J,EAQlB4J,YAAY7E,EAAW8E,GACnB,MAAMhI,EAASqG,KACfrG,EAAOQ,GAAKN,EAAWgD,GACvBlD,EAAOC,OAASlC,EAAM,CAAC,EAAG8J,EAAO1J,SAAU6J,GAC3ChI,EAAOqD,GCtBc,MAKzB,MAAM4E,EAAW,CACb,CAACpL,GAAc,GACf,CAACC,GAAa,GACd,CAACC,GAAa,GACd,CAACC,GAAe,GAChB,IAAa,IAGjB,MAAO,CAOHsG,EAAMkB,KAAS0D,GACXD,EAASzD,GAAMrD,SAAQsD,IACnBA,EAAQ1G,EAAM,CAAC,EAAG,CAAEyG,WAAW0D,GAA/B,GAEP,EAQDC,EAAI3D,EAAMC,GACNwD,EAASzD,IAASyD,EAASzD,GAAMR,KAAKS,EACzC,EAQD2D,EAAK5D,EAAMC,GACP,IAAI4D,EAAgBJ,EAASzD,GAEzB6D,EAGAJ,EAASzD,GAAQC,EAAU4D,EAAcC,QAAOC,GAAmBA,IAAoB9D,IAAW,GAClF,OAATD,GACP5G,EAAeqK,GAAU,CAACO,EAAKhE,KAC3ByD,EAASzD,GAAQ,EAAjB,GAIX,EA1CL,EDSgBiE,GACZzI,EAAO0I,GAAKtF,EAASpD,EACxB,CAOD2I,WAAWX,GACPjK,EAAMsI,KAAKpG,OAAQ+H,EACtB,CAQDY,GAAGpE,EAAMC,GACL4B,KAAKhD,GAAG8E,EAAI3D,EAAMC,EACrB,CAQDoE,IAAIrE,EAAMC,GACN4B,KAAKhD,GAAG+E,EAAK5D,EAAMC,EACtB,CAQD2B,QAAQX,GACJ,IAAIrC,EAAWiD,KAAKqC,GACpB,OAAOtF,EAASoC,EAAiBC,EAAWrC,EAASI,IACxD,CAKDsF,UACI/I,EAAWsG,MAAM,EACpB,CAKD0C,SACIhJ,EAAWsG,MAAM,EACpB,CAKD2C,UACI,MAAMhJ,EAASqG,KAEfrG,EAAO0I,GAAGvE,IACVvG,EAAeoC,GAAQ,CAAC0C,EAAKzG,YAClB+D,EAAO/D,EAAd,GAEP,E","sources":["webpack://Tartib/webpack/universalModuleDefinition","webpack://Tartib/webpack/bootstrap","webpack://Tartib/webpack/runtime/define property getters","webpack://Tartib/webpack/runtime/hasOwnProperty shorthand","webpack://Tartib/./src/js/constants.js","webpack://Tartib/./src/js/utils/object.js","webpack://Tartib/./src/js/defaults.js","webpack://Tartib/./src/js/utils/classes.js","webpack://Tartib/./src/js/placeholder/position.js","webpack://Tartib/./src/js/utils/util.js","webpack://Tartib/./src/js/utils/dom.js","webpack://Tartib/./src/js/scroll/scroll.js","webpack://Tartib/./src/js/utils/dragPoint.js","webpack://Tartib/./src/js/placeholder/insert.js","webpack://Tartib/./src/js/core/sortable.js","webpack://Tartib/./src/js/core/list.js","webpack://Tartib/./src/js/core/events/binder.js","webpack://Tartib/./src/js/scroll/scrollable.js","webpack://Tartib/./src/js/scroll/autoScroll.js","webpack://Tartib/./src/js/index.js","webpack://Tartib/./src/js/core/events/listener.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Tartib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tartib\"] = factory();\n\telse\n\t\troot[\"Tartib\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const ROOT = document;\nexport const HTML = ROOT.documentElement;\nexport const BODY = ROOT.body;\n\nexport const INSERT_BEFORE = 'beforebegin';\nexport const INSERT_AFTER = 'afterend';\n\nexport const START_EVENT = 'start';\nexport const MOVE_EVENT = 'move';\nexport const SORT_EVENT = 'sort';\nexport const CHANGE_EVENT = 'change';\nexport const END_EVENT = 'end';\n\nexport const { floor, abs } = Math;\n\n\nexport const METHODS = {\n    x: {\n\t\t_scrollProperty: 'scrollLeft',\n\t\t_scrollDimension: 'scrollWidth',\n\t\t_lowerBound: 'left',\n\t\t_upperBound: 'right',\n\t\t_dimension: 'width'\n\t},\n\t\n\ty: {\n\t\t_scrollProperty: 'scrollTop',\n\t\t_scrollDimension: 'scrollHeight',\n\t\t_lowerBound: 'top',\n\t\t_upperBound: 'bottom',\n\t\t_dimension: 'height'\n\t}\n}","/**\n * Iterate in an object, stop and return false if callback function returns true.\n *\n * @param {Object} object - Any object.\n * @param {CallableFunction} fn - Any Callback function.\n * @returns {Boolean}\n */\nexport const objectIterator = (object, fn) => {\n    for (const key in object) {\n        if (Object.hasOwnProperty.call(object, key)) {\n            fn(object[key], key);\n        }\n    }\n}\n\n/**\n * Merges two or more objects together into the target object.\n *\n * @param {Object} target - Object that will receive the new properties.\n * @param  {...Object} sources - Objects containing additional properties to merge in.\n * @returns {Object}\n */\nexport const merge = (target, ...sources) => Object.assign(target, ...sources);\n\n\n/**\n * Checks if a value is an object.\n *\n * @param {any} value - Value to check if it's an object.\n * @returns {Boolean}\n */\nexport const isObject = value => typeof value === 'object' && value != null && ! Array.isArray(value);","export const defaults = {\n    /**\n     * x, y coordinates relative to the dragged element top left corner.\n     * x and y can be numbers or percentages, e.g. '50%'\n     *\n     * @type {Object}\n     */\n    dragFrom: {},\n\n    /**\n     * Set cursor while dragging an item.\n     *\n     * @type {String}\n     */\n    cursor: '',\n\n    /**\n     * Adds a box shadow to the dragged item.\n     *\n     * @type {Boolean}\n     */\n    elevation: true,\n\n    /**\n     * Adds class(es) to the dragged item. this(those) class(es),\n     * will be removed when dragging is done.\n     *\n     * @type {String}\n     */\n    active: '',\n\n    /**\n     * Adds class(es) to the placeholder.\n     *\n     * @type {String}\n     */\n    placeholder: '',\n\n    /**\n     * A Selector or an Element to drag the item from.\n     *\n     * @type {String|Element}\n     */\n    dragHandle: '',\n\n    /**\n     * Lock movement to only one axis 'x' or 'y'.\n     *\n     * @type {String}\n     */\n    axis: false,\n\n    /**\n     * Disable sorting.\n     *\n     * @type {Boolean}\n     */\n    disabled: false,\n\n    /**\n     * Sets opacity to the dragged item, value must be between 0 and 1 exclusive.\n     *\n     * @type {Number}\n     */\n    opacity: false,\n\n    /**\n     * Auto scroll while dragging an item, to show out of viewport items.\n     *\n     * @type {Boolean}\n     */\n    autoScroll: true,\n\n    /**\n     * Sort right to left for the x axis.\n     *\n     * @type {Boolean}\n     */\n    rtl: false,\n}","export const TARTIB_CLASSNAME = 'tartib';\nexport const ITEM_CLASSNAME = 'tartib__item';\nexport const ITEM_SELECTOR = '.' + ITEM_CLASSNAME;\nexport const ITEM_DRAGGED_CLASSNAME = ITEM_CLASSNAME + '--dragged';\nexport const ELEVATION_CLASSNAME = 'tartib--elevation';\nexport const PLACEHOLDER_CLASSNAME = 'tartib__placeholder';","import { INSERT_AFTER, INSERT_BEFORE, METHODS } from \"../constants\";\n\n/**\n * Gets placeholder's next position.\n *\n * @param {Object} targetBounds        - Target element bounding rect object.\n * @param {Number} mouseStart          - Mouse starting position.\n * @param {Number} mousePosition       - Mouse position.\n * @param {Boolean} isVertical         - Indicate whether the sorting is vertically or horizontally.\n * @param {String|undefined} placeholderPosition - Used for the diagonal positionning, the position of the placeholder in the other axis.\n * @returns {String}\n */\nexport const getPlaceholderPosition = (targetBounds, mouseStart, mousePosition, axis, isRTL, placeholderPosition) => {\n\n    let position;\n    let methods = METHODS[axis];\n\n    // This indicates whether the mouse intersected the,\n    // next element half (50% of its dimension) width or height.\n    let nextElMouseIntersection = mousePosition > targetBounds[axis] + targetBounds[methods._dimension] * 0.5;\n    // Mouse movement, whether if its moving down or to the right.\n    let movement = mouseStart[axis] < mousePosition;\n\n    // Mouse is moving down or to the right.\n    // Otherwise, mouse is moving up or to the left.\n    if (movement) {\n        if (nextElMouseIntersection || placeholderPosition) {\n            position = isRTL ? INSERT_BEFORE : INSERT_AFTER;\n        }\n    } else {\n        // Mouse intersected the previous element.\n        if (! nextElMouseIntersection || placeholderPosition) {\n            position = isRTL ? INSERT_AFTER : INSERT_BEFORE;\n        }\n    }\n\n    return position;\n}","/**\n * Checks if a value is a string.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isString = value => typeof value === 'string';\n\n/**\n * Disables/Enables Tartib.\n *\n * @param {Object} tartib - Instance.\n * @param {Boolean} disabled - A state to set.\n */\nexport const setDisable = (tartib, disabled) => {\n    tartib.config.disabled = disabled;\n}","import { ROOT } from \"../constants\";\nimport { objectIterator } from \"./object\";\nimport { isString } from \"./util\";\n\n/**\n * Gets a DOM element.\n *\n * @param {String|Element} ref - CSS selector or DOM element.\n * @param {Element} context - Element to search from.\n * @param {Boolean} all - Get all elements.\n * @returns {NodeList|Element|null}\n */\nexport const getElement = (ref, context, all) => isString(ref) ? ref && (context || ROOT)['querySelector' + (all ? 'All' : '')](ref)\n                                : ref instanceof Element ? ref\n                                : null;\n\n\n/**\n * Gets element bounds.\n *\n * @param {HTMLElement} el Element.\n * @returns {Object}\n */\nexport const getBounds = (el) => el && el.getBoundingClientRect();\n\n/**\n * Gets an element's parent.\n *\n * @param {Element} el - Any html element.\n * @returns {Element}\n */\nexport const getParent = el => el.parentElement;\n\n/**\n * Adds inline styles to an element.\n *\n * @param {Element} el - Any Element.\n * @param {Object} styles - Inline styles.\n */\nexport const inlineStyles = (el, styles) => {\n\n    if (styles) {\n        objectIterator(styles, (value, property) => {\n            el.style[property] = value;\n        });\n    } else {\n        el.style = null;\n    }\n}\n\n/**\n * Updates element's classes.\n *\n * @param {Element} el - Any DOM Element.\n * @param {String|Array} classes - Element classes.\n * @param {Boolean} remove - Whether to remove classes.\n */\nconst updateList = (el, classes, remove) => {\n\n    if (isString(classes)) {\n        classes = [classes];\n    }\n\n    classes.forEach(classname => {\n        classname = isString(classname) && classname.split(/\\s+/);\n\n        classname.forEach(cls => {\n            if (cls) {\n                el.classList[remove ? 'remove' : 'add'](cls);\n            }\n        });\n    });\n}\n\n/**\n * Adds/Removes classes.\n *\n * @param {Element} el - Any DOM Element.\n * @returns {Object}\n */\nexport const classList = el => ({\n    /**\n     * Adds classes to el classList.\n     *\n     * @param {Array|String} classes - Classes to add.\n     */\n    _add(classes) {\n        updateList(el, classes);\n    },\n\n    /**\n     * Removes classes from el classList.\n     *\n     * @param {Array|String} classes - Classes to remove.\n     */\n    _remove(classes) {\n        updateList(el, classes, true);\n    }\n});","import { abs, METHODS } from \"../constants\";\n\n/**\n * Scrolls ancestors that hides parts of the sortable list.\n *\n * @param {Element} el - Scrollable element.\n * @param {Object} elBounds - Scrollable element bounding rect.\n * @param {Object} itemBounds - Item's bounding rect.\n * @param {Boolean} isVertical - Indicates whether to scroll Vertically or horizontally.\n * @param {Boolean} isRTL - Indicates whether the list is in RTL direction.\n */\nexport const scroll = (el, elBounds, itemBounds, axis, isRTL) => {\n\n    /**\n     * All these variables are property names (methods), depending on the axis.\n     */\n    let { _lowerBound, _upperBound, _scrollProperty, _scrollDimension, _dimension } = METHODS[axis];\n\n    /**\n     * Scroll direction (top | right | bottom | left).\n     * @type {String}\n     */\n    let scrollTowards;\n    let scrollAmount = abs(el[_scrollProperty]);\n    let isScrolled = scrollAmount > 0;\n    let isFullScrolled = scrollAmount < el[_scrollDimension] - elBounds[_dimension];\n\n    // Scroll up or left.\n    if (( isRTL ? isFullScrolled : isScrolled) && itemBounds[_lowerBound] < elBounds[_lowerBound]) {\n        scrollTowards = _lowerBound;\n        // Scroll bottom or right.\n    } else if ((isRTL ? isScrolled : isFullScrolled) && itemBounds[_upperBound] > elBounds[_upperBound]) {\n        scrollTowards = _upperBound;\n    }\n\n    if (scrollTowards) {\n        el[_scrollProperty] += itemBounds[scrollTowards] - elBounds[scrollTowards];\n    }\n}","import { METHODS } from \"../constants\";\nimport { getBounds } from \"./dom\";\nimport { isObject, objectIterator } from \"./object\";\nimport { isString } from \"./util\";\n\n\n/**\n * Gets drag from point.\n *\n * @param {Element} item    - Dragged item.\n * @param {Ojbect} dragFrom - Pointer position relative to the dragged item.\n * @param {Object} pointer    - Pointer position.\n * @param {Element} handle - Drag handle.\n * @param {Boolean} isRTL - Whether Scrollable is in rtl direction.\n * @returns {Object}\n */\nexport const getDragPoint = (item, dragFrom, pointer, handle, isRTL) => {\n    dragFrom = isObject(dragFrom) ? dragFrom : {};\n\n    let bounds = getBounds(handle || item);\n    let itemBounds = handle ? getBounds(item) : bounds;\n    let point = {};\n    let dragVal;\n\n    objectIterator(pointer, (val, axis) => {\n        dragVal = dragFrom[axis];\n\n        if (dragVal === '' || isNaN(dragVal)) {\n            // If it's a percentage.\n            if (isString(dragVal) && /^\\d*.?\\d+\\s*%$/.test(dragVal.trim())) {\n                dragVal = parseFloat(dragVal) * bounds[METHODS[axis]._dimension] / 100;\n            } else {\n                // Invalid value.\n                dragVal = null;\n            }\n        } else {\n            // Number or a String number, convert it to number.\n            dragVal *= 1;\n        }\n\n\n        if (dragVal != null) {\n\n            if (isRTL && axis === 'x') {\n                dragVal = bounds.width - dragVal;\n            }\n\n            dragVal += bounds[axis];\n        } else {\n            dragVal = val;\n        }\n\n        point[axis] = dragVal - itemBounds[axis];\n    });\n\n    return point;\n}","import { INSERT_AFTER, INSERT_BEFORE } from \"../constants\";\n\n/**\n * Inserts a placeholder element into the list.\n *\n * @param {String} where - Where to insert the element.\n * @param {Element} reference - Insert placeholder element before or after this element. \n * @param {Element} element - Element to insert. \n */\nexport const insertPlaceholder = (where, reference, placeholder) => {\n    let sibling = {\n        [INSERT_BEFORE]: 'previous',\n        [INSERT_AFTER]: 'next'\n    }\n\n    // Check if the element is not already exist.\n    if (reference[sibling[where] + 'ElementSibling'] !== placeholder) {\n        reference.insertAdjacentElement(where, placeholder);\n    }\n}","import { ELEVATION_CLASSNAME, ITEM_DRAGGED_CLASSNAME, PLACEHOLDER_CLASSNAME } from \"../utils/classes\";\nimport { getPlaceholderPosition } from \"../placeholder/position\";\nimport { autoScroll } from \"../scroll/autoScroll\";\nimport { classList, getBounds, getElement, getParent, inlineStyles } from \"../utils/dom\";\nimport { getDragPoint } from \"../utils/dragPoint\";\nimport { EventBinder } from \"./events/binder\";\nimport { getScrollableAncestors } from \"../scroll/scrollable\";\nimport { insertPlaceholder } from \"../placeholder/insert\";\nimport { CHANGE_EVENT, END_EVENT, floor, HTML, INSERT_BEFORE, METHODS, MOVE_EVENT, ROOT, SORT_EVENT, START_EVENT } from \"../constants\";\nimport { List } from \"./list\";\n\n/**\n * Sorts a list by dragging its items.\n *\n * @param {Tartib} tartib - Instance.\n */\nexport const sortable = (tartib) => {\n\n    const { el, config, _e: { _emit } } = tartib;\n\n    /**\n     * List.\n     */\n    const { _getItem, _getItems } = List(el);\n\n    /**\n     * Event binder methods.\n     */\n    const { _bind, _clear } = EventBinder();\n\n    /**\n     * Dragged List Item.\n     *\n     * @type {Element}\n     */\n    let draggedItem;\n\n    /**\n     * Placeholder Item.\n     *\n     * @type {Element}\n     */\n    let placeholder;\n\n    /**\n     * List scrollable ancestors elements.\n     *\n     * @type {Array<Element>}\n     */\n    let scrollableAncestors;\n\n    /**\n     * Dragged Item classList.\n     *\n     * @type {Object}\n     */\n    let itemClassList;\n\n    /**\n     * Dragged Item Bounding rect.\n     *\n     * @type {DOMRect}\n     */\n    let itemBounds;\n\n    /**\n     * Array of list items.\n     *\n     * @type {Array<Element>}\n     */\n    let startList;\n\n    /**\n     * Start pointer coordinates.\n     *\n     * @type {Object} \n     */\n    let startPoint = {}\n\n    /**\n     * Drag at coordinates.\n     *\n     * @type {Object}\n     */\n    let dragPoint = {}\n\n    /**\n     * Event Object Data.\n     *\n     * @type {Object}\n     */\n    let eventObject;\n\n    /**\n     * Indicates whether a dragged item start moving.\n     */\n    let startMoving = false;\n\n    /**\n     * Indicates whether an item is dragged.\n     */\n    let isDragging = false;\n\n    /**\n     * Right To Left Direction.\n     */\n    let isRTL;\n\n    /**\n     * Lock movement to one axis.\n     *\n     * @type {Object}\n     */\n    let axisLock;\n\n    /**\n     * Starts dragging.\n     *\n     * @param {Event} e - Mousedown.\n     */\n    const dragStart = e => {\n\n        let { dragHandle, dragFrom, disabled, autoScroll, rtl, axis } = config;\n        let { target, pointerId, clientX, clientY } = e;\n\n        \n        draggedItem = _getItem(target);\n\n        /**\n         * Exit, if disabled or pointer down wasn't in a list item,\n         * or in a drag handle.\n         */\n        if (disabled || !draggedItem || (dragHandle && target !== getElement(dragHandle, draggedItem))) {\n            return;\n        }\n\n        isRTL = rtl;\n        axisLock = {\n            x: axis !== 'y',\n            y: axis !== 'x'\n        }\n\n        target.releasePointerCapture(pointerId);\n        placeholder = draggedItem.cloneNode();\n        placeholder.id = '';\n        startList = _getItems();\n\n        itemClassList = classList(draggedItem);\n\n        startPoint = {\n            x: clientX,\n            y: clientY\n        }\n\n        eventObject = {\n            el,\n            x: 0,\n            y: 0,\n            target: draggedItem,\n            relatedTarget: null,\n            placeholder,\n            items: startList,\n            getData(attribute) {\n                return _getAttributeMap(attribute, this.items);\n            }\n        }\n\n        dragPoint = getDragPoint(draggedItem, dragFrom, startPoint, dragHandle ? target : null, isRTL);\n        scrollableAncestors = autoScroll ? getScrollableAncestors(el) : [];\n        isDragging = true;\n    }\n\n    /**\n     * moves an item.\n     *\n     * @param {Event} e - Mousemove.\n     */\n    const dragMove = e => {\n        if (isDragging) {\n            let { target: relatedTarget, clientX, clientY } = e;\n            let data;\n\n            if (! startMoving) {\n                setItemPosition(startPoint.x, startPoint.y, {});\n\n                let { cursor, elevation, placeholder: placeholderClassname, opacity, active } = config;\n                let { width, height, x, y } = getBounds(draggedItem);\n\n                height += 'px';\n                width += 'px';\n\n                inlineStyles(draggedItem, {\n                    width,\n                    height,\n                    opacity: opacity > 0 && opacity < 1 ? opacity : false,\n                });\n                inlineStyles(HTML, { cursor });\n                inlineStyles(placeholder, { height });\n\n                _emit(START_EVENT, eventObject, { x, y });\n\n                itemClassList._add([ITEM_DRAGGED_CLASSNAME, elevation && ELEVATION_CLASSNAME, active]);\n\n                classList(placeholder)._add(placeholderClassname || PLACEHOLDER_CLASSNAME);\n                insertPlaceholder(INSERT_BEFORE, draggedItem, placeholder);\n                startMoving = true;\n            }\n\n            /**\n             * Move item.\n             */\n            setItemPosition(clientX, clientY, axisLock);\n\n            itemBounds = getBounds(draggedItem);\n\n            data = {\n                x: itemBounds.x,\n                y: itemBounds.y\n            }\n\n            /**\n             * Fire move event.\n             */\n            _emit(MOVE_EVENT, eventObject, data, { relatedTarget });\n\n            /**\n             * Scroll to view where to drop.\n             */\n            autoScroll(scrollableAncestors, itemBounds, isRTL);\n\n            relatedTarget = _getItem(relatedTarget);\n\n            if (el.contains(relatedTarget) && relatedTarget !== placeholder) {\n                let bounds = getBounds(relatedTarget);\n                let { top, right, bottom, left } = getBounds(placeholder);\n                let movingVertically = clientX <= floor(right) && clientX >= floor(left) && axisLock.y;\n                let movingHorizontally = clientY <= floor(bottom) && clientY >= floor(top) && axisLock.x;\n                let position;\n\n                // Sorting item diagonally.\n                if (! movingHorizontally && ! movingVertically && (axisLock.x && axisLock.y)) {\n                    // Get position horizontally, pass it to the vertical position.\n                    position = getPlaceholderPosition(bounds, startPoint, clientX, 'x', isRTL);\n                    position = getPlaceholderPosition(bounds, startPoint, clientY, 'y', false, position);\n                } else {\n                    // Sorting item vertically.\n                    if (! movingHorizontally) {\n                        position = getPlaceholderPosition(bounds, startPoint, clientY, 'y', false);\n                    }\n\n                    // Sorting item horizontally.\n                    if (! movingVertically) {\n                        position = getPlaceholderPosition(bounds, startPoint, clientX, 'x', isRTL);\n                    }\n                }\n\n                if (position) {\n                    insertPlaceholder(position, relatedTarget, placeholder);\n                    startPoint.y = clientY;\n                    startPoint.x = clientX;\n\n                    /**\n                     * Fire sort event.\n                     */\n                    _emit(SORT_EVENT, eventObject, data, { \n                        relatedTarget,\n                        items: _getItems(),\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Ends dragging.\n     *\n     * @param {Event} e - Mouseup.\n     */\n    const dragEnd = e => {\n        if (isDragging) {\n\n            if (getParent(placeholder) === el) {\n                el.replaceChild(draggedItem, placeholder);\n                placeholder = null;\n            }\n\n            let endList = _getItems();\n            let data = {\n                placeholder,\n                items: endList\n            }\n\n            inlineStyles(draggedItem);\n            inlineStyles(HTML, { cursor: '' });\n\n            itemClassList._remove([ITEM_DRAGGED_CLASSNAME, ELEVATION_CLASSNAME, config.active]);\n\n            if (startList.some((item, index) => item !== endList[index])) {\n                /**\n                 * Fire change event.\n                 */\n                _emit(CHANGE_EVENT, eventObject, data);\n            }\n\n            if (startMoving) {\n                /**\n                 * Fire end event.\n                 */\n                _emit(END_EVENT, eventObject, data);\n            }\n\n            isDragging = startMoving = false;\n        }\n    }\n\n    /**\n     * Sets item position.\n     *\n     * @param {Number} x - Mouse X coordinate.\n     * @param {Number} y - Mouse Y coordinate.\n     * @param {Object} axis - Axis option.\n     */\n    const setItemPosition = (x, y, axis) => {\n\n        if (isRTL) {\n            x -= HTML[METHODS.x._scrollProperty];\n        }\n\n\n        if (axis.y) {\n            draggedItem.style.top = y - dragPoint.y + 'px';\n        }\n\n        if (axis.x) {\n            draggedItem.style.left = x - dragPoint.x + 'px';\n        }\n    }\n\n\n    /**\n     * Gets an array, each value is an attribute value of a list item.\n     *\n     * @param {String} attribute - Element attribute name.\n     * @param {Array<Element>} items - Sortable list items.\n     * @returns {Array}\n     */\n    const _getAttributeMap = (attribute, items) => items.map(item => item.getAttribute(attribute || 'id'));\n\n    /**\n     * Events.\n     */\n    _bind(el, 'pointerdown', dragStart);\n    _bind(ROOT, 'pointermove', dragMove);\n    _bind(ROOT, 'pointerup', dragEnd);\n\n    return {\n        _clear,\n        _getAttributeMap,\n        _getItems\n    }\n}","import { ITEM_SELECTOR, PLACEHOLDER_CLASSNAME } from \"../utils/classes\";\nimport { getElement } from \"../utils/dom\";\n\n/**\n * Sortable list.\n *\n * @param {Element} el - Sortable List element.\n * @returns {Object}\n */\nexport const List = el => ({\n\n    /**\n     * Gets List item.\n     *\n     * @param {Element} target - Event Target.\n     * @returns {Element|null}\n     */\n    _getItem: target => target.closest(ITEM_SELECTOR),\n\n    /**\n     * Gets sortable list items.\n     *\n     * @param {Element} list - Sortabale list.\n     * @returns {Array<Element>}\n     */\n    _getItems() {\n         let nodeList = getElement(ITEM_SELECTOR, el, true);\n         let items = [];\n         let length = nodeList.length;\n\n         for (let i = 0; i < length; i++) {\n             const element = nodeList[i];\n             // Exclude placeholder item.\n             if (! element.classList.contains(PLACEHOLDER_CLASSNAME)) {\n                 items.push(element);\n             }\n         }\n         return items;\n     }\n\n})","/**\n * Binds/Unbinds events listeners.\n *\n * @returns {Object}\n */\nexport const EventBinder = () => {\n    const listeners = [];\n\n    /**\n     * Binds/Unbinds an event listener.\n     *\n     * @param {Array} listener - Event listener array.\n     * @param {Boolean} unbind - Indicates whether to unbind the listener or not.\n     */\n    const binder = (listener, unbind) => {\n        listener[0][(unbind ? 'remove': 'add') + 'EventListener'](listener[1], listener[2]);\n    }\n\n    return {\n        /**\n         * Registers and Adds an event listener.\n         */\n        _bind(target, type, handler) {\n            let listener = [target, type, handler];\n            binder(listener);\n            listeners.push(listener);\n        },\n\n        /**\n         * Removes all events listeners.\n         */\n        _clear() {\n            listeners.forEach(listener => {\n                binder(listener, true);\n            });\n        }\n    }\n}","import { BODY, HTML } from \"../constants\";\nimport { getBounds, getParent } from \"../utils/dom\";\n\n/**\n * Gets scrollable ancestors elements.\n *\n * @param {Element} el - Element to get its scrollable ancestors.\n * @returns {Array}\n */\nexport const getScrollableAncestors = (el) => {\n    let scrollableAncestors = [];\n    let elHeight = el.scrollHeight;\n    let elWidth = el.scrollWidth;\n\n    while (el !== null) {\n        let overflow = getComputedStyle(el).overflow;\n        let { width, height } = getBounds(el);\n        let isRoot = el === HTML;\n\n        if (isRoot) {\n            height = HTML.clientHeight;\n        }\n\n        if (\n            (overflow === 'auto' || overflow === 'scroll' || (isRoot && overflow === 'visible'))\n            &&\n            (height < elHeight || width < elWidth)\n            &&\n            el !== BODY\n        ) {\n            scrollableAncestors.push(el);\n        }\n\n        el = getParent(el);\n    }\n\n    return scrollableAncestors;\n}","import { HTML } from \"../constants\";\nimport { getBounds } from \"../utils/dom\";\nimport { scroll } from \"./scroll\";\n\n/**\n * Auto scrolls parent scrollables that hide part of the list, when dragging\n * a list item.\n *\n * @param {Array} scrollables - Scrollable elements.\n * @param {DOMRect} itemBounds - List item bounding rect.\n * @param {Boolean} isRTL - Indicates if the list is in RTL direction.\n */\nexport const autoScroll  = (scrollables, itemBounds, isRTL) => {\n    scrollables.forEach(scrollable => {\n        let bounds = getBounds(scrollable);\n\n        if (scrollable === HTML) {\n            let domHeight = HTML.clientHeight;\n            let width = bounds.width;\n\n            bounds = {\n                top: 0,\n                left: 0,\n                right: width,\n                bottom: domHeight,\n                height: domHeight,\n                width\n            }\n        }\n\n        // Scroll for each axis.\n        scroll(scrollable, bounds, itemBounds, 'x', isRTL);\n        scroll(scrollable, bounds, itemBounds, 'y', false);\n    });\n}\n\n","import '../sass/tartib.scss';\nimport { EventListener } from './core/events/listener';\nimport { defaults } from './defaults';\nimport { sortable } from './core/sortable';\nimport { merge, objectIterator } from './utils/object';\nimport { setDisable } from './utils/util';\nimport { getElement } from './utils/dom';\n\nexport default class Tartib {\n\n    /**\n     * Tartib version.\n     */\n    static version = VERSION;\n\n    /**\n     * Tartib defaults.\n     */\n    static defaults = defaults;\n\n    /**\n     * Constructor.\n     *\n     * @param {String|Element} reference - List element or its selector.\n     * @param {Object} options - Tartib options.\n     */\n    constructor(reference, options) {\n        const tartib = this;\n        tartib.el = getElement(reference);\n        tartib.config = merge({}, Tartib.defaults, options);\n        tartib._e = EventListener();\n        tartib._s = sortable(tartib);\n    }\n\n    /**\n     * Sets options.\n     *\n     * @param {Object} options - Tartib new options.\n     */\n    setOptions(options) {\n        merge(this.config, options);\n    }\n\n    /**\n     * Attaches an event listener.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    on(type, handler) {\n        this._e._on(type, handler);\n    }\n\n    /**\n     * Removes an event listener.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    off(type, handler) {\n        this._e._off(type, handler);\n    }\n\n    /**\n     * Gets an array of each item's attribute value.\n     *\n     * @param {String} attribute - Element attribute name.\n     * @returns {Array<String>}\n     */\n    getData(attribute) {\n        let sortable = this._s;\n        return sortable._getAttributeMap(attribute, sortable._getItems());\n    }\n\n    /**\n     * Disable sorting.\n     */\n    disable() {\n        setDisable(this, true);\n    }\n\n    /**\n     * Enable sorting.\n     */\n    enable() {\n        setDisable(this, false);\n    }\n\n    /**\n     * Removes this instance functionality.\n     */\n    destroy() {\n        const tartib = this;\n\n        tartib._s._clear();\n        objectIterator(tartib, (val, prop) => {\n            delete tartib[prop];\n        });\n    }\n}","import { CHANGE_EVENT, END_EVENT, MOVE_EVENT, SORT_EVENT, START_EVENT } from \"../../constants\";\nimport { merge, objectIterator } from \"../../utils/object\";\n\n/**\n * Tartib events.\n *\n * @returns {Object}\n */\nexport const EventListener = () => {\n\n    /**\n     * Tartib event handlers.\n     */\n    const handlers = {\n        [START_EVENT]: [],\n        [MOVE_EVENT]: [],\n        [SORT_EVENT]: [],\n        [CHANGE_EVENT]: [],\n        [END_EVENT]: []\n    }\n\n    return {\n        /**\n         * Emits an event.\n         *\n         * @param {String} type - Event type.\n         * @param  {Element|Object} source - Event Source.\n         */\n        _emit(type, ...args) {\n            handlers[type].forEach(handler => {\n                handler(merge({}, { type }, ...args));\n            });\n        },\n\n        /**\n         * Adds an event listener.\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        _on(type, handler) {\n            handlers[type] && handlers[type].push(handler);\n        },\n\n        /**\n         * Removes event listener(s).\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        _off(type, handler) {\n            let handlersArray = handlers[type];\n\n            if (handlersArray) {\n                // Remove the handler if it's specified,\n                // Remove all handlers of this event if handler is omitted.\n                handlers[type] = handler ? handlersArray.filter(attachedHanlder => attachedHanlder !== handler) : [];\n            } else if (type === null) {\n                objectIterator(handlers, (arr, type) => {\n                    handlers[type] = [];\n                });\n            }\n\n        }\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ROOT","document","HTML","documentElement","BODY","body","INSERT_BEFORE","INSERT_AFTER","START_EVENT","MOVE_EVENT","SORT_EVENT","CHANGE_EVENT","floor","abs","Math","METHODS","x","_scrollProperty","_scrollDimension","_lowerBound","_upperBound","_dimension","y","objectIterator","object","fn","merge","target","sources","assign","defaults","dragFrom","cursor","elevation","active","placeholder","dragHandle","axis","disabled","opacity","autoScroll","rtl","ITEM_SELECTOR","ITEM_DRAGGED_CLASSNAME","ITEM_CLASSNAME","ELEVATION_CLASSNAME","PLACEHOLDER_CLASSNAME","getPlaceholderPosition","targetBounds","mouseStart","mousePosition","isRTL","placeholderPosition","position","methods","nextElMouseIntersection","isString","value","setDisable","tartib","config","getElement","ref","context","all","Element","getBounds","el","getBoundingClientRect","getParent","parentElement","inlineStyles","styles","property","style","updateList","classes","remove","forEach","classname","split","cls","classList","_add","_remove","scroll","elBounds","itemBounds","scrollTowards","scrollAmount","isScrolled","isFullScrolled","getDragPoint","item","pointer","handle","Array","isArray","dragVal","bounds","point","val","isNaN","test","trim","parseFloat","width","insertPlaceholder","where","reference","insertAdjacentElement","sortable","_e","_emit","_getItem","_getItems","closest","nodeList","items","length","i","element","contains","push","List","_bind","_clear","listeners","binder","listener","unbind","type","handler","EventBinder","draggedItem","scrollableAncestors","itemClassList","startList","eventObject","axisLock","startPoint","dragPoint","startMoving","isDragging","setItemPosition","top","left","_getAttributeMap","attribute","map","getAttribute","e","pointerId","clientX","clientY","releasePointerCapture","cloneNode","id","relatedTarget","getData","this","elHeight","scrollHeight","elWidth","scrollWidth","overflow","getComputedStyle","height","isRoot","clientHeight","getScrollableAncestors","data","placeholderClassname","scrollables","scrollable","domHeight","right","bottom","movingVertically","movingHorizontally","replaceChild","endList","some","index","Tartib","VERSION","constructor","options","handlers","args","_on","_off","handlersArray","filter","attachedHanlder","arr","EventListener","_s","setOptions","on","off","disable","enable","destroy"],"sourceRoot":""}